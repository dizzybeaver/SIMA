# DT-05.md

**REF-ID:** DT-05  
**Category:** Decision Logic  
**Subcategory:** Error Handling  
**Name:** How to Handle This Error  
**Priority:** High  
**Status:** Active  
**Created:** 2024-10-30  
**Updated:** 2024-10-30

---

## Summary

Decision tree for error handling strategies - determining whether to handle gracefully, retry with backoff, log, or propagate errors based on error type and recoverability.

---

## Problem

Different error types require different handling strategies. Expected errors should be handled gracefully, transient errors should be retried, and unexpected errors should propagate with proper logging.

---

## Decision Tree

```
START: Error occurred in function
│
├─ Q: Is this expected/recoverable error?
│  ├─ YES → Handle gracefully
│  │      Examples: Cache miss, file not found, validation failed
│  │      Pattern:
│  │        try:
│  │            result = risky_operation()
│  │        except SpecificError:
│  │            log_warning("Expected error occurred")
│  │            return default_value
│  │      → END
│  │
│  └─ NO (unexpected) → Continue
│
├─ Q: Can operation be retried?
│  ├─ YES → Retry with backoff
│  │      Examples: Network timeout, rate limit
│  │      Pattern:
│  │        for attempt in range(3):
│  │            try:
│  │                return risky_operation()
│  │            except RetryableError:
│  │                time.sleep(2 ** attempt)
│  │        raise  # Failed all retries
│  │      → END
│  │
│  └─ NO → Continue
│
├─ Q: Should error be logged?
│  ├─ NO (sensitive/spammy) → Log at debug level
│  │      gateway.log_debug(f"Error: {e}")
│  │      → Continue
│  │
│  └─ YES → Log at appropriate level
│         gateway.log_error(f"Error: {e}", error=e)
│         → Continue
│
└─ Q: Should error propagate to caller?
   ├─ YES → Re-raise
   │      Pattern:
   │        try:
   │            result = operation()
   │        except Exception as e:
   │            log_error(f"Failed: {e}", error=e)
   │            raise  # Propagate
   │      → END
   │
   └─ NO → Return error indicator
          Pattern:
            try:
                result = operation()
                return {'success': True, 'data': result}
            except Exception as e:
                log_error(f"Failed: {e}", error=e)
                return {'success': False, 'error': str(e)}
          → END
```

---

## Error Handling Matrix

| Error Type | Action | Log Level | Propagate? | Example |
|------------|--------|-----------|------------|---------|
| Cache miss | Handle gracefully | WARNING | NO | Return None |
| Validation error | Handle gracefully | WARNING | NO | Return error dict |
| Network timeout | Retry (3x) | ERROR (after retries) | YES | Exponential backoff |
| DB connection | Retry (3x) | ERROR (after retries) | YES | Reconnect attempts |
| File not found | Handle gracefully | WARNING | Context-dependent | Return empty/None |
| Division by zero | Propagate | ERROR | YES | Math error |
| Unknown error | Log and propagate | ERROR | YES | Unexpected condition |

---

## Examples

### Example 1: Expected Error - Handle Gracefully

**Scenario:** Cache miss is expected behavior

**Implementation:**
```python
from gateway import log_warning, cache_get

def get_user_data(user_id: str) -> dict:
    """Get user data with cache miss handling."""
    try:
        data = cache_get(f"user:{user_id}")
        if data is None:
            # Expected: cache miss
            log_warning(f"Cache miss for user {user_id}")
            data = fetch_from_database(user_id)
        return data
    except Exception as e:
        # Unexpected errors still propagate
        log_error(f"Failed to get user data: {e}", error=e)
        raise
```

### Example 2: Retryable Error - Exponential Backoff

**Scenario:** Network timeout should be retried

**Implementation:**
```python
from gateway import log_info, log_error
import time

def fetch_api_data(url: str, max_retries: int = 3) -> dict:
    """Fetch API data with retry logic."""
    for attempt in range(max_retries):
        try:
            log_info(f"Fetching {url} (attempt {attempt + 1}/{max_retries})")
            return http_get(url, timeout=5)
        except TimeoutError as e:
            if attempt < max_retries - 1:
                wait_time = 2 ** attempt  # 1s, 2s, 4s
                log_warning(f"Timeout, retrying in {wait_time}s: {e}")
                time.sleep(wait_time)
            else:
                # All retries exhausted
                log_error(f"All retries failed for {url}", error=e)
                raise
```

### Example 3: Log and Propagate

**Scenario:** Database error should be logged and propagated

**Implementation:**
```python
from gateway import log_error

def save_to_database(data: dict) -> bool:
    """Save data with error logging."""
    try:
        db_connection = get_db_connection()
        db_connection.execute("INSERT INTO...", data)
        return True
    except DatabaseError as e:
        # Log with full context
        log_error(
            f"Database save failed: {e}",
            error=e,
            data_keys=list(data.keys()),
            db_host=db_connection.host
        )
        # Propagate to caller
        raise
```

### Example 4: Return Error Dict (Don't Propagate)

**Scenario:** API endpoint should return error without raising

**Implementation:**
```python
from gateway import log_error

def process_request(request_data: dict) -> dict:
    """Process request and return result dict."""
    try:
        # Validate
        if not request_data.get('user_id'):
            return {
                'success': False,
                'error': 'Missing user_id',
                'error_code': 'VALIDATION_ERROR'
            }
        
        # Process
        result = perform_operation(request_data)
        return {
            'success': True,
            'data': result
        }
    except Exception as e:
        # Log error
        log_error(f"Request processing failed: {e}", error=e)
        
        # Return error dict instead of raising
        return {
            'success': False,
            'error': str(e),
            'error_code': 'PROCESSING_ERROR'
        }
```

---

## Log Level Guidelines

### ERROR Level
- Unexpected failures
- After all retry attempts exhausted
- Database/system errors
- Operations that will cause request failure

### WARNING Level
- Expected errors (cache miss, validation failure)
- Configuration issues with fallback
- Deprecated feature usage
- Recoverable errors

### DEBUG Level
- Sensitive information
- Verbose debugging details
- Expected operational events
- Development-only information

### INFO Level
- Normal operations
- Success events
- State changes
- Performance metrics

---

## Anti-Patterns

### ❌ Bare Except Clause

**Problem:**
```python
try:
    operation()
except:  # Catches EVERYTHING including KeyboardInterrupt!
    pass
```

**Solution:**
```python
try:
    operation()
except SpecificError as e:  # Catch specific exceptions
    log_error(f"Operation failed: {e}", error=e)
    raise
```

### ❌ Swallowing Exceptions

**Problem:**
```python
try:
    critical_operation()
except Exception:
    pass  # Error disappears silently!
```

**Solution:**
```python
try:
    critical_operation()
except Exception as e:
    log_error(f"Critical operation failed: {e}", error=e)
    raise  # Or return error dict if appropriate
```

### ❌ No Error Context

**Problem:**
```python
except Exception as e:
    log_error("Error")  # What error? Where? Why?
```

**Solution:**
```python
except Exception as e:
    log_error(
        f"Failed to process user {user_id}: {e}",
        error=e,
        user_id=user_id,
        operation='process_user'
    )
```

---

## Related Patterns

**From NM04 (Decisions):**
- **DEC-15:** Error handling design

**From NM05 (Anti-Patterns):**
- **AP-14:** Bare except clauses
- **AP-15:** Swallowing exceptions
- **AP-16:** No error context

**From NM07 (Decision Logic):**
- **DT-06:** What exception type to raise

---

## Keywords

error handling, exceptions, retry logic, graceful degradation, error propagation, logging, exception handling

---

## Version History

- **2024-10-30:** Migrated to SIMAv4 format from NM07 v3
- **2024-10-24:** Created in SIMAv3 format

---

**File:** `DT-05.md`  
**Location:** `/sima/entries/decisions/error-handling/`  
**End of Document**
