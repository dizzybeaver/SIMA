# AP-23.md - No Unit Tests

**REF-ID:** AP-23  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Topic:** Testing  
**Priority:** ðŸŸ  HIGH  
**Status:** Active  
**Created:** 2025-10-30  
**Last Updated:** 2025-10-30

---

## Summary

Deploying code without unit tests makes refactoring dangerous, hides bugs until production, and creates fear-based development where nobody dares change anything.

---

## Context

Writing tests feels slow during initial development. But lack of tests creates massive technical debt that compounds over time, eventually grinding development to a halt.

**Problem:** Hidden bugs, dangerous refactoring, fear of changes, regression nightmares.

---

## Content

### The Anti-Pattern

```python
# âŒ NO TESTS - Just ship it!
def calculate_total(items):
    total = 0
    for item in items:
        total += item['price'] * item['quantity']
    return total

# Deployed to production without any tests!
# What if items is None?
# What if items is empty?
# What if price/quantity missing?
# What if price is negative?
```

### Why This Is Dangerous

**1. Hidden Bugs**
```python
# Code looks fine, bugs hidden
def process_discount(price, discount):
    return price - (price * discount / 100)

# Bug: What if discount > 100?
# Result: Negative price!
# Discovered: In production, after customer complaint
```

**2. Regression Risk**
```python
# Developer changes code
def calculate_total(items):
    # "Optimization": Use sum() instead of loop
    return sum(item['price'] * item['qty'] for item in items)
    # Typo: 'qty' instead of 'quantity'
    # No tests to catch it
    # Broken in production
```

**3. Fear-Based Development**
```python
# 6 months later, need to modify calculate_total
# Developer: "It works, I'm afraid to touch it"
# Manager: "Just add feature without changing existing code"
# Result: Workarounds, duplicated code, tech debt
```

**4. Debugging in Production**
```python
# Bug report: "Totals wrong"
# No tests to reproduce
# Must debug in production
# Add logging, wait for error
# Days of investigation
# Tests would have caught it in seconds
```

### Correct Approach

```python
# âœ… WITH COMPREHENSIVE TESTS
def calculate_total(items):
    """Calculate total cost from items list."""
    if items is None:
        raise ValueError("Items cannot be None")
    
    total = 0
    for item in items:
        price = item.get('price', 0)
        quantity = item.get('quantity', 0)
        
        if price < 0:
            raise ValueError(f"Price cannot be negative: {price}")
        if quantity < 0:
            raise ValueError(f"Quantity cannot be negative: {quantity}")
            
        total += price * quantity
    
    return total

# tests/test_calculations.py
import pytest

def test_calculate_total_normal():
    """Test standard case."""
    items = [
        {'price': 10.0, 'quantity': 2},
        {'price': 5.0, 'quantity': 3}
    ]
    assert calculate_total(items) == 35.0

def test_calculate_total_empty():
    """Test empty list."""
    assert calculate_total([]) == 0

def test_calculate_total_none():
    """Test None input."""
    with pytest.raises(ValueError, match="cannot be None"):
        calculate_total(None)

def test_calculate_total_missing_price():
    """Test missing price field."""
    items = [{'quantity': 2}]
    assert calculate_total(items) == 0  # Defaults to 0

def test_calculate_total_negative_price():
    """Test negative price."""
    items = [{'price': -10, 'quantity': 1}]
    with pytest.raises(ValueError, match="Price cannot be negative"):
        calculate_total(items)

def test_calculate_total_negative_quantity():
    """Test negative quantity."""
    items = [{'price': 10, 'quantity': -1}]
    with pytest.raises(ValueError, match="Quantity cannot be negative"):
        calculate_total(items)
```

### Minimum Test Coverage

**Required coverage:**
- Happy path (normal success)
- Edge cases (empty, boundary values)
- Error cases (invalid input)

**Coverage targets:**
- 80%+ line coverage (minimum)
- 90%+ for critical paths
- 100% for security/financial code

**Per function:**
- At least 3 test cases
- Cover main branches
- Test error handling

### Testing Guidelines

**What to test:**
```python
# âœ… Test business logic
def calculate_discount(price, tier):
    # Test this
    pass

# âœ… Test edge cases
def process_batch(items):
    # Test empty, single item, large batch
    pass

# âœ… Test error handling
def validate_input(data):
    # Test invalid inputs
    pass
```

**What NOT to test:**
```python
# âŒ Don't test framework code
# âŒ Don't test external libraries
# âŒ Don't test simple getters/setters
# âŒ Don't test language features
```

### Detection

```bash
# Check for missing tests
find src -name "*.py" -type f | while read file; do
    basename=$(basename "$file" .py)
    if [ ! -f "tests/test_${basename}.py" ]; then
        echo "Missing tests for: $file"
    fi
done

# Check test coverage
pytest --cov=src --cov-report=term-missing
pytest --cov=src --cov-report=html

# Fail CI if coverage too low
pytest --cov=src --cov-fail-under=80
```

### Test Structure

**Arrange-Act-Assert pattern:**
```python
def test_feature():
    # Arrange - setup
    input_data = create_test_data()
    expected = calculate_expected(input_data)
    
    # Act - execute
    result = function_under_test(input_data)
    
    # Assert - verify
    assert result == expected
```

**Given-When-Then pattern:**
```python
def test_user_login():
    # Given - precondition
    user = create_user("john", "password123")
    
    # When - action
    result = login(user.username, "password123")
    
    # Then - outcome
    assert result.success is True
    assert result.user_id == user.id
```

### Test Organization

```
project/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ calculations.py
â”‚   â”œâ”€â”€ validation.py
â”‚   â””â”€â”€ database.py
â””â”€â”€ tests/
    â”œâ”€â”€ test_calculations.py  # Mirrors src structure
    â”œâ”€â”€ test_validation.py
    â”œâ”€â”€ test_database.py
    â””â”€â”€ conftest.py  # Shared fixtures
```

---

## Related Topics

- **AP-24**: Testing Only Success Paths - Need comprehensive tests
- **AP-28**: Deploying Untested - Never deploy without tests

---

## Keywords

unit testing, test coverage, TDD, pytest, regression testing, quality assurance

---

## Version History

- **2025-10-30**: Created - Generic testing patterns

---

**File:** `AP-23.md`  
**Lines:** ~195  
**End of Document**
