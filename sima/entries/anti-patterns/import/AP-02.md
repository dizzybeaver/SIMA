# File: AP-02.md

**REF-ID:** AP-02  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Type:** Import Violations  
**Severity:** ðŸ"´ Critical  
**Status:** Active

---

## SUMMARY

Importing interface router files directly instead of using gateway functions. This bypasses the gateway layer and violates the three-layer architecture pattern.

---

## THE ANTI-PATTERN

### What NOT to Do

```python
# âŒ WRONG - Direct interface router import
from interface_cache import cache_get, cache_set
from interface_logging import log_info, log_error

def my_function():
    cache_get("mykey")
    log_info("Started")
```

### Why It's Bad

1. **Bypasses Gateway Layer** - Skips centralized control point
2. **No Error Handling** - Misses gateway-level error management
3. **No Metrics** - Gateway-level metrics not collected
4. **Tight Coupling** - Code depends on interface structure
5. **Breaks on Refactoring** - Interface changes break your code

---

## WHAT TO DO INSTEAD

### Correct Approach

```python
# âœ… CORRECT - Via gateway
import gateway

def my_function():
    gateway.cache_get("mykey")
    gateway.log_info("Started")
```

### Why This Is Better

- Gateway provides stable API
- Error handling built-in
- Metrics automatically collected
- Interface refactoring doesn't break your code
- Centralized control point

---

## REAL-WORLD EXAMPLE

### Context

Developer wanted "more efficient" code by skipping gateway layer.

### Problem Code

```python
# In lambda_function.py
from interface_cache import cache_get
from interface_logging import log_info

def handler(event, context):
    value = cache_get(event['key'])
    log_info("Retrieved value")
    return value
```

### What Went Wrong

1. Cache interface refactored (renamed functions)
2. Lambda code broke in production
3. No error metrics collected (skipped gateway)
4. 30-minute outage

### Solution

```python
# In lambda_function.py
import gateway

def handler(event, context):
    value = gateway.cache_get(event['key'])
    gateway.log_info("Retrieved value")
    return value
```

### Result

- Survived interface refactoring without changes
- Automatic error handling
- Metrics collected properly

---

## THE THREE-LAYER PATTERN

### Correct Flow

```
Your Code
    â†"
gateway.cache_get()
    â†"
interface_cache.cache_get()
    â†"
cache_core.get_value()
```

### Wrong Flow

```
Your Code
    â†"
interface_cache.cache_get()  # Skipping gateway!
    â†"
cache_core.get_value()
```

### Why Gateway Layer Exists

- Consistent error handling
- Metrics collection
- Request validation
- Future optimization opportunities
- Stable public API

---

## HOW TO IDENTIFY

### Code Smells

- `from interface_* import` statements in application code
- Direct calls to interface router functions
- Code breaks when interface structure changes

### Detection

```bash
# Find interface router imports
grep -r "from interface_.* import" *.py

# Should return zero results in application code
```

### Quick Test

If you see `interface_` in your import statements in application code, you're doing it wrong.

---

## EXCEPTION: GATEWAY INTERNAL CODE

### Only Exception

```python
# âœ… ALLOWED - Inside gateway.py or gateway_wrappers.py
# In gateway_wrappers_cache.py
from interface_cache import cache_get as _cache_get

def cache_get(key, ttl=None):
    """Gateway wrapper for cache operations."""
    # Add gateway-level logic
    return _cache_get(key, ttl)
```

### Rule

Only gateway-layer code should import interface routers. Application code never should.

---

## IMPACT ANALYSIS

### Performance Impact

```
Gateway overhead: ~50ns additional
Interface direct: ~50ns
Gateway call: ~100ns

For typical operation (1-100ms):
Overhead: 0.01% - 0.0001% (negligible)

Trade-off: 50ns overhead vs architectural benefits
Conclusion: Gateway overhead is negligible
```

### Maintenance Impact

```
Without gateway:
- Interface refactor = Update all call sites
- Add validation = Update all callers
- Change error handling = Update everywhere

With gateway:
- Interface refactor = Gateway adapts, callers unchanged
- Add validation = Once at gateway
- Change error handling = Once at gateway
```

### Stability Impact

```
Direct interface calls:
- Tightly coupled to implementation
- Breaks on interface changes
- No protection against errors

Gateway calls:
- Loosely coupled via stable API
- Survives interface refactoring
- Protected by gateway error handling
```

---

## RELATED PATTERNS

### Must Read First
- **ARCH-01** - SUGA Pattern (three-layer architecture)
- **DEC-02** - Gateway Centralization (why gateway exists)
- **GATE-01** - Three-File Structure

### Related Rules
- **GATE-03** - Cross-Interface Communication
- **GATE-02** - Lazy Loading

### Related Anti-Patterns
- **AP-01** - Direct Cross-Interface Imports
- **AP-03** - Gateway for Same-Interface Operations

---

## DETECTION AND PREVENTION

### Code Review Checklist

- [ ] No `from interface_* import` in application code
- [ ] All operations use `gateway.operation()`
- [ ] Interface imports only in gateway layer
- [ ] No direct interface router calls

### Automated Detection

```python
# Lint rule example
def check_interface_imports(file_path):
    if is_gateway_file(file_path):
        return  # Gateway files are exempt
    
    for line in read_file(file_path):
        if 'from interface_' in line and 'import' in line:
            raise LintError(f"AP-02 violation: {line}")
```

---

## MIGRATION GUIDE

### If You Find This Pattern

**Step 1:** Identify the interface import
```python
from interface_cache import cache_get  # âŒ Found it!
```

**Step 2:** Replace with gateway
```python
import gateway  # âœ… Add this
```

**Step 3:** Update function calls
```python
cache_get("key")  # âŒ Old way
gateway.cache_get("key")  # âœ… New way
```

**Step 4:** Remove interface import
```python
# from interface_cache import cache_get  # âŒ Delete this
```

**Step 5:** Test
```bash
python -m pytest tests/test_your_module.py
```

---

## SEVERITY JUSTIFICATION

### Why Critical

1. **Architectural Violation** - Bypasses core pattern
2. **Fragile Code** - Breaks on interface changes
3. **Lost Functionality** - No gateway-level features
4. **Maintenance Cost** - Higher coupling = higher cost
5. **Silent Failures** - Errors not tracked properly

### Incident History

- **2025-10-20:** Production outage from interface refactoring
- **2025-09-15:** Metrics gap due to skipped gateway
- **2025-08-10:** Error handling inconsistencies

**Total incidents:** 5 over 3 months  
**MTTR:** 25 minutes average  
**Prevention:** Use gateway exclusively

---

## KEYWORDS

interface routers, direct imports, gateway bypass, architecture violation, three-layer pattern, coupling

---

## VERSION HISTORY

### [1.0.0] - 2025-10-30
- Migrated to SIMAv4 format
- Added performance impact analysis
- Added migration guide
- Enhanced detection methods

### [0.9.0] - 2025-10-23
- SIMA v3 individual file format

### [0.1.0] - 2024-10-15
- Initial documentation

---

**END OF ANTI-PATTERN ENTRY**

**Related:** AP-01, AP-03, ARCH-01, DEC-02, GATE-01, GATE-03
