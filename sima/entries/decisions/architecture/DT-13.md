# DT-13.md

**REF-ID:** DT-13  
**Category:** Decision Logic  
**Subcategory:** Architecture  
**Name:** New Interface or Extend Existing  
**Priority:** High  
**Status:** Active  
**Created:** 2024-10-30  
**Updated:** 2024-10-30

---

## Summary

Decision tree for architectural interface decisions, determining when new functionality warrants a new interface versus extending existing interface versus adding to utilities.

---

## Problem

SUGA architecture uses focused interfaces. Teams need clear criteria for when to create new interfaces versus extending existing ones to maintain clean boundaries while avoiding interface proliferation.

---

## Decision Tree

```
START: Need new functionality
│
├─ Q: Does functionality fit existing interface?
│  ├─ YES → Extend existing interface
│  │      Example: cache.list_keys → CACHE interface
│  │      → END
│  │
│  └─ NO → Continue
│
├─ Q: Is functionality substantial (>200 lines)?
│  ├─ NO → Add to UTILITY interface
│  │      Example: String helpers
│  │      → END
│  │
│  └─ YES → Continue
│
├─ Q: Does functionality have its own state?
│  ├─ YES → Create new interface
│  │      Example: Database connection pool
│  │      → CREATE NEW INTERFACE
│  │
│  └─ NO → Continue
│
├─ Q: Is functionality domain-specific?
│  ├─ YES → Create new interface
│  │      Example: Email sending, File storage
│  │      → CREATE NEW INTERFACE
│  │
│  └─ NO → Add to UTILITY interface
│         Example: Generic helpers
│         → END
```

---

## Examples

### Example 1: Email Sending - CREATE NEW INTERFACE

**Scenario:** Need email sending capability

**Analysis:**
```
Functionality: Email sending (SMTP, templates, delivery)
Questions:
- Fits existing interface? NO (no EMAIL interface exists)
- >200 lines? YES (SMTP logic, templates, connection management)
- Has own state? YES (connection pool, credentials, configuration)
- Domain-specific? YES (email is distinct domain)
- Used by multiple? YES (notifications, alerts, reports)
```

**Decision:** **CREATE NEW INTERFACE**

**Implementation:**
```python
# 1. Add to GatewayInterface enum
class GatewayInterface(Enum):
    EMAIL = "email"

# 2. Create interface_email.py (router)
def route_email_operation(operation, params):
    """Route email operations."""
    dispatch = {
        'send': _execute_send_implementation,
        'send_template': _execute_send_template_implementation,
        'get_status': _execute_get_status_implementation,
    }
    return dispatch[operation](params)

# 3. Create email_core.py (implementation)
def _execute_send_implementation(params):
    """Send email via SMTP."""
    to = params['to']
    subject = params['subject']
    body = params['body']
    # SMTP connection and sending logic
    return {'message_id': '...', 'status': 'sent'}

# 4. Register in gateway_core.py
INTERFACE_ROUTERS = {
    GatewayInterface.EMAIL: interface_email.route_email_operation,
}

# 5. Add wrappers
def email_send(to, subject, body):
    """Send email."""
    return gateway.route(GatewayInterface.EMAIL, 'send', {
        'to': to,
        'subject': subject,
        'body': body
    })
```

**Benefit:** Clean separation, focused responsibility, maintainable

### Example 2: Cache List Keys - EXTEND EXISTING

**Scenario:** Need to list all cache keys

**Analysis:**
```
Functionality: List all keys in cache
Questions:
- Fits existing interface? YES (cache operation on CACHE interface)
- CACHE interface exists? YES
```

**Decision:** **EXTEND CACHE INTERFACE**

**Implementation:**
```python
# In interface_cache.py
_OPERATION_DISPATCH = {
    'get': _execute_get_implementation,
    'set': _execute_set_implementation,
    'delete': _execute_delete_implementation,
    'list_keys': _execute_list_keys_implementation,  # ADDED
}

# In cache_core.py
def _execute_list_keys_implementation(params):
    """List all cache keys (or matching pattern)."""
    pattern = params.get('pattern', '*')
    keys = _cache_storage.keys(pattern)
    return {'keys': list(keys)}

# In gateway_wrappers.py (optional)
def cache_list_keys(pattern='*'):
    """List cache keys matching pattern."""
    return gateway.cache('list_keys', {'pattern': pattern})
```

**Benefit:** No new interface needed, natural fit

### Example 3: String Helpers - ADD TO UTILITY

**Scenario:** Need string manipulation helpers

**Analysis:**
```
Functionality: to_camel_case(), to_snake_case(), truncate()
Questions:
- Fits existing interface? NO (no STRING interface)
- >200 lines? NO (simple helper functions)
- Has own state? NO (stateless)
- Domain-specific? NO (generic utilities)
```

**Decision:** **ADD TO UTILITY INTERFACE**

**Implementation:**
```python
# In utility_core.py
def to_camel_case(snake_str):
    """Convert snake_case to camelCase."""
    components = snake_str.split('_')
    return components[0] + ''.join(x.title() for x in components[1:])

def to_snake_case(camel_str):
    """Convert camelCase to snake_case."""
    return ''.join(['_' + c.lower() if c.isupper() else c 
                    for c in camel_str]).lstrip('_')

def truncate(text, length, suffix='...'):
    """Truncate text to length with suffix."""
    if len(text) <= length:
        return text
    return text[:length - len(suffix)] + suffix

# Optional: Add wrappers
def utility_to_camel_case(text):
    """Convert to camelCase."""
    return gateway.utility('to_camel_case', {'text': text})
```

**Benefit:** Grouped with other utilities, no interface overhead

### Example 4: File Storage - CREATE NEW INTERFACE

**Scenario:** Need S3/file storage operations

**Analysis:**
```
Functionality: Upload, download, list, delete files
Questions:
- Fits existing interface? NO (no FILE interface)
- >200 lines? YES (S3 client, upload/download logic, multipart)
- Has own state? YES (S3 client, bucket config, credentials)
- Domain-specific? YES (file storage is distinct domain)
- Used by multiple? YES (logs, backups, user uploads)
```

**Decision:** **CREATE NEW INTERFACE**

**Implementation:**
```python
# 1. Add FILE interface
class GatewayInterface(Enum):
    FILE = "file"

# 2. Create interface_file.py
def route_file_operation(operation, params):
    """Route file storage operations."""
    dispatch = {
        'upload': _execute_upload_implementation,
        'download': _execute_download_implementation,
        'list': _execute_list_implementation,
        'delete': _execute_delete_implementation,
    }
    return dispatch[operation](params)

# 3. Create file_core.py
def _execute_upload_implementation(params):
    """Upload file to S3."""
    key = params['key']
    data = params['data']
    # S3 upload logic
    return {'location': f's3://bucket/{key}'}

# 4. Register and add wrappers
```

**Benefit:** Dedicated interface for file operations, proper state management

### Example 5: When to Split Existing Interface

**Scenario:** HTTP interface growing too large

**Analysis:**
```
Current: http_core.py (1200 lines)
Contains:
- HTTP requests (400 lines)
- WebSocket management (300 lines)
- Request transformation (250 lines)
- Response parsing (250 lines)

Signs to split:
âœ… Exceeds 1000 lines
âœ… Multiple responsibilities
âœ… Natural sub-domains
```

**Decision:** **SPLIT INTO FOCUSED FILES** (same interface)

**Implementation:**
```python
# Split into:
# http_client_core.py (requests)
# http_client_state.py (connection management)
# http_client_transformation.py (data transform)
# http_client_validation.py (validation)

# Still ONE interface: GatewayInterface.HTTP
# Just better internal organization
```

**Benefit:** Better organization, same interface boundary

---

## Related Patterns

**Decision Logic:**
- **DT-02**: Where Should Function Go (function placement)
- **DT-03**: User Wants Feature X (feature requests)

**Architecture:**
- **ARCH-04**: Three-File Interface Pattern (implementation)
- **DEC-01**: SUGA Pattern (architecture choice)

**Lessons:**
- **LESS-06**: Interface Design Lessons
- **LESS-07**: Gateway Evolution Patterns

---

## Keywords

new interface, extend interface, interface decision, architecture growth, SUGA pattern, interface design, interface boundaries, feature architecture, state management, domain separation

---

## Version History

- **2024-10-30:** Migrated to SIMAv4 format from NM07 v3
- **2024-10-24:** Created in SIMAv3 format

---

**File:** `DT-13.md`  
**Location:** `/sima/entries/decisions/architecture/`  
**End of Document**
