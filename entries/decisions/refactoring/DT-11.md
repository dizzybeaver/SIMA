# DT-11.md

**REF-ID:** DT-11  
**Category:** Decision Logic  
**Subcategory:** Refactoring  
**Name:** Extract to Function or Leave Inline  
**Priority:** Low  
**Status:** Active  
**Created:** 2024-10-30  
**Updated:** 2024-10-30

---

## Summary

Decision tree for function extraction, determining when to extract code blocks into separate functions versus leaving them inline based on reuse, size, and single responsibility principle.

---

## Problem

Function extraction improves readability and reusability but adds indirection. Teams need clear criteria for when extraction benefits outweigh added complexity.

---

## Decision Tree

```
START: Code block that could be extracted
│
├─ Q: Is code used >2 times?
│  ├─ YES → Extract to function
│  │      DRY principle (Don't Repeat Yourself)
│  │      → EXTRACT
│  │
│  └─ NO → Continue
│
├─ Q: Is code >10 lines?
│  ├─ YES → Consider extracting
│  │      May aid readability
│  │      → Continue
│  │
│  └─ NO → Continue
│
├─ Q: Does code have clear single purpose?
│  ├─ YES → Extract to function
│  │      Single Responsibility Principle
│  │      → EXTRACT
│  │
│  └─ NO → Leave inline
│         Extraction would be artificial
│         → END
│
└─ Q: Would extraction improve readability?
   ├─ YES → Extract
   │      Name makes code self-documenting
   │      → EXTRACT
   │
   └─ NO → Leave inline
          Don't add unnecessary indirection
          → END
```

---

## Examples

### Example 1: Extract - Used Multiple Times (DRY)

**Scenario:** Same validation repeated in 3 functions

**Before:**
```python
# ❌ Duplicated validation logic
def process_user(user):
    if not user.get('email'):
        raise ValueError("Email required")
    if '@' not in user.get('email', ''):
        raise ValueError("Invalid email")
    # ... process user

def update_user(user):
    if not user.get('email'):
        raise ValueError("Email required")
    if '@' not in user.get('email', ''):
        raise ValueError("Invalid email")
    # ... update user

def delete_user(user):
    if not user.get('email'):
        raise ValueError("Email required")
    if '@' not in user.get('email', ''):
        raise ValueError("Invalid email")
    # ... delete user
```

**After:**
```python
# âœ… Extracted reusable function
def validate_email(email):
    """Validate email format and presence."""
    if not email:
        raise ValueError("Email required")
    if '@' not in email:
        raise ValueError("Invalid email")
    return True

def process_user(user):
    validate_email(user.get('email'))
    # ... process user

def update_user(user):
    validate_email(user.get('email'))
    # ... update user

def delete_user(user):
    validate_email(user.get('email'))
    # ... delete user
```

**Benefit:** DRY principle, single source of truth for validation

### Example 2: Extract - Clear Single Purpose

**Scenario:** Code block with distinct purpose within larger function

**Before:**
```python
# ❌ Mixed concerns in one function
def process_request(request):
    # Validation (15 lines with clear purpose)
    if not request:
        return {"error": "Missing request"}
    if 'data' not in request:
        return {"error": "Missing data"}
    data = request['data']
    if not isinstance(data, dict):
        return {"error": "Invalid data type"}
    if not data.get('id'):
        return {"error": "Missing id"}
    
    # Processing (main logic)
    result = transform(data)
    return {"result": result}
```

**After:**
```python
# âœ… Extracted with clear purpose
def validate_request(request):
    """Validate request structure and contents.
    
    Returns: (bool, error_msg) tuple
    """
    if not request:
        return False, "Missing request"
    if 'data' not in request:
        return False, "Missing data"
    
    data = request['data']
    if not isinstance(data, dict):
        return False, "Invalid data type"
    if not data.get('id'):
        return False, "Missing id"
    
    return True, None

def process_request(request):
    """Process validated request."""
    valid, error = validate_request(request)
    if not valid:
        return {"error": error}
    
    result = transform(request['data'])
    return {"result": result}
```

**Benefit:** Single Responsibility Principle, validation extracted

### Example 3: Don't Extract - Simple Inline Code

**Scenario:** Short, used once, no clear boundary

**Current (Good):**
```python
# âœ… Simple inline - don't extract
def calculate_total(items):
    """Calculate total with tax."""
    subtotal = sum(item.price for item in items)
    tax = subtotal * 0.08  # 8% tax rate
    return subtotal + tax
```

**Unnecessary Extraction:**
```python
# ❌ Over-extracted - adds no value
def calculate_tax(subtotal):
    """Calculate 8% tax."""
    return subtotal * 0.08

def calculate_total(items):
    """Calculate total with tax."""
    subtotal = sum(item.price for item in items)
    tax = calculate_tax(subtotal)  # Unnecessary indirection
    return subtotal + tax
```

**Decision:** DON'T EXTRACT
- Used once
- Simple calculation (one line)
- No reuse benefit
- Adds unnecessary indirection

### Example 4: Extract - Improves Readability

**Scenario:** Long function benefits from breaking into named steps

**Before:**
```python
# ❌ Long function, hard to scan
def handle_alexa_request(request):
    # Validation
    if not request:
        return error_response("Missing request")
    if 'directive' not in request:
        return error_response("Missing directive")
    # ... 10 more validation lines
    
    # Processing
    directive = request['directive']
    header = directive['header']
    # ... 20 more processing lines
    
    # Response formatting
    response = {}
    response['event'] = {}
    response['event']['header'] = {}
    # ... 10 more formatting lines
    
    return response
```

**After:**
```python
# âœ… Clear steps with named functions
def validate_alexa_request(request):
    """Validate request structure."""
    if not request:
        return False, "Missing request"
    if 'directive' not in request:
        return False, "Missing directive"
    # ... validation logic
    return True, None

def process_directive(directive):
    """Process directive and extract data."""
    header = directive['header']
    # ... processing logic
    return processed_data

def format_alexa_response(data):
    """Format response for Alexa."""
    response = {
        'event': {
            'header': {},
            # ... formatting logic
        }
    }
    return response

def handle_alexa_request(request):
    """Handle Alexa request with clear steps."""
    valid, error = validate_alexa_request(request)
    if not valid:
        return error_response(error)
    
    data = process_directive(request['directive'])
    return format_alexa_response(data)
```

**Benefit:** Self-documenting structure, easier to test and maintain

### Example 5: Don't Extract - No Clear Boundary

**Scenario:** Artificial extraction with no clear purpose

**Current (Good):**
```python
# âœ… Domain-specific calculation, keep inline
def calculate_score(stats):
    """Calculate player score from game stats."""
    base = stats.get('kills', 0) * 10
    bonus = stats.get('assists', 0) * 5
    penalty = stats.get('deaths', 0) * -3
    multiplier = 1 + (stats.get('streak', 0) * 0.1)
    return (base + bonus + penalty) * multiplier
```

**Artificial Extraction:**
```python
# ❌ Over-engineered - no clear benefit
def calculate_base_score(kills):
    return kills * 10

def calculate_bonus_score(assists):
    return assists * 5

def calculate_penalty(deaths):
    return deaths * -3

def calculate_multiplier(streak):
    return 1 + (streak * 0.1)

def calculate_score(stats):
    """Calculate player score (now harder to understand)."""
    base = calculate_base_score(stats.get('kills', 0))
    bonus = calculate_bonus_score(stats.get('assists', 0))
    penalty = calculate_penalty(stats.get('deaths', 0))
    multiplier = calculate_multiplier(stats.get('streak', 0))
    return (base + bonus + penalty) * multiplier
```

**Decision:** DON'T EXTRACT
- Extraction is artificial
- No reuse
- Harder to understand formula
- Better to see calculation in one place

---

## Related Patterns

**Decision Logic:**
- **DT-10**: Should I Refactor This Code (refactoring decisions)
- **DT-02**: Where Should Function Go (function placement)

**Anti-Patterns:**
- **AP-20**: Unnecessary Complexity (avoid over-extraction)
- **AP-21**: Inconsistent Patterns (maintain extraction consistency)

**Lessons:**
- **LESS-13**: Keep Functions Focused (function design)
- **LESS-01**: Read Complete Files First (context before extraction)

---

## Keywords

function extraction, code organization, DRY principle, single responsibility, inline code, code readability, function design, refactoring, code structure

---

## Version History

- **2024-10-30:** Migrated to SIMAv4 format from NM07 v3
- **2024-10-24:** Created in SIMAv3 format

---

**File:** `DT-11.md`  
**Location:** `/sima/entries/decisions/refactoring/`  
**End of Document**
