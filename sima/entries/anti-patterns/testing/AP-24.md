# AP-24.md - Testing Only Success Paths

**REF-ID:** AP-24  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Topic:** Testing  
**Priority:** üü† HIGH  
**Status:** Active  
**Created:** 2025-10-30  
**Last Updated:** 2025-10-30

---

## Summary

Writing tests that only verify success paths while ignoring error cases, edge cases, and failure modes. This leaves bugs hidden in error handling code that only triggers in production.

---

## Context

Success path testing feels productive ("look, it passes!") but provides false confidence. Real-world usage includes invalid input, network failures, and edge cases that success-only tests never check.

**Problem:** Hidden error handling bugs, false confidence, production failures in edge cases.

---

## Content

### The Anti-Pattern

```python
# ‚ùå ONLY SUCCESS PATH TESTED
def test_process_data():
    """Test data processing."""
    result = process_data({"valid": "data"})
    assert result == "success"
    
# Missing tests:
# - What if data is None?
# - What if data is empty dict?
# - What if data has wrong structure?
# - What if processing raises exception?
# - What if network call fails?
```

### Why This Is Dangerous

**1. Error Handling Never Tested**
```python
def process_payment(amount, card):
    try:
        charge_card(card, amount)
        return "success"
    except PaymentError as e:
        # This code never tested!
        log.error(f"Payment failed: {e}")
        return "failed"

# Only success test exists
def test_process_payment():
    assert process_payment(100, valid_card()) == "success"
    # Error handling code has bug - never discovered!
```

**2. Edge Cases Cause Production Failures**
```python
def divide_numbers(a, b):
    return a / b

# Only tests happy path
def test_divide_numbers():
    assert divide_numbers(10, 2) == 5

# Production: divide_numbers(10, 0)
# Result: ZeroDivisionError - never tested!
```

**3. Validation Bugs Hidden**
```python
def create_user(username, email):
    if not username:
        raise ValueError("Username required")
    if "@" not in email:
        raise ValueError("Invalid email")
    return User(username, email)

# Only tests valid input
def test_create_user():
    user = create_user("john", "john@example.com")
    assert user.username == "john"
    
# Validation code never tested!
# Production: Typo in validation message
# Users see broken error messages
```

### Correct Approach

```python
# ‚úÖ TEST SUCCESS AND ALL FAILURE MODES

def test_process_data_success():
    """Test normal success case."""
    result = process_data({"valid": "data"})
    assert result == "success"

def test_process_data_none():
    """Test None input."""
    with pytest.raises(ValueError, match="Data cannot be None"):
        process_data(None)

def test_process_data_empty():
    """Test empty dict."""
    result = process_data({})
    assert result == "default"

def test_process_data_missing_field():
    """Test missing required field."""
    with pytest.raises(KeyError, match="'required_field'"):
        process_data({"wrong": "field"})

def test_process_data_invalid_type():
    """Test invalid data type."""
    with pytest.raises(TypeError, match="Expected dict"):
        process_data("string")

def test_process_data_network_error():
    """Test network failure handling."""
    with patch('requests.post', side_effect=ConnectionError):
        result = process_data({"valid": "data"})
        assert result == "retry_later"
```

### Test Checklist

**For EVERY function, test:**
- [ ] Success case (happy path)
- [ ] None input
- [ ] Empty input (empty string, list, dict)
- [ ] Invalid input type
- [ ] Missing required fields/parameters
- [ ] Boundary conditions (0, max, min)
- [ ] Error handling paths
- [ ] Exception cases
- [ ] Timeout scenarios (if applicable)
- [ ] Concurrent access (if applicable)

### Testing Error Handling

**Pattern 1: Expected exceptions**
```python
# ‚úÖ TEST THAT EXCEPTIONS ARE RAISED
def test_validation_error():
    with pytest.raises(ValueError, match="Invalid input"):
        validate_input("bad data")
```

**Pattern 2: Error recovery**
```python
# ‚úÖ TEST THAT ERRORS ARE HANDLED
def test_network_error_retry():
    with patch('api.call', side_effect=[NetworkError, Success]):
        result = fetch_with_retry()
        assert result.success is True
        assert result.retry_count == 1
```

**Pattern 3: Partial failures**
```python
# ‚úÖ TEST MIXED SUCCESS/FAILURE
def test_batch_partial_failure():
    items = [valid_item, invalid_item, valid_item]
    results = process_batch(items)
    assert results.success_count == 2
    assert results.failure_count == 1
    assert len(results.errors) == 1
```

### Edge Cases to Test

**Numeric boundaries:**
```python
def test_boundaries():
    assert process(0) == expected_for_zero
    assert process(-1) == expected_for_negative
    assert process(sys.maxsize) == expected_for_max
```

**String edge cases:**
```python
def test_string_edges():
    assert process("") == expected_for_empty
    assert process(" ") == expected_for_whitespace
    assert process("x" * 10000) == expected_for_long
```

**Collection edge cases:**
```python
def test_collection_edges():
    assert process([]) == expected_for_empty_list
    assert process([item]) == expected_for_single
    assert process([item] * 1000) == expected_for_large
```

### Testing Anti-Patterns

**Anti-Pattern 1: No assertions**
```python
# ‚ùå SMOKE TEST - Just checks it doesn't crash
def test_process():
    process_data()  # No assertion!
    # Test always passes even if wrong result
```

**Anti-Pattern 2: Weak assertions**
```python
# ‚ùå WEAK - Only checks not None
def test_get_users():
    users = get_users()
    assert users is not None  # Could be empty, wrong structure, etc.

# ‚úÖ STRONG - Checks structure and content
def test_get_users():
    users = get_users()
    assert isinstance(users, list)
    assert len(users) > 0
    assert all('id' in u and 'name' in u for u in users)
```

**Anti-Pattern 3: Testing implementation**
```python
# ‚ùå TESTING IMPLEMENTATION DETAILS
def test_cache_uses_dict():
    cache = Cache()
    assert isinstance(cache._storage, dict)  # Brittle!

# ‚úÖ TEST BEHAVIOR
def test_cache_stores_and_retrieves():
    cache = Cache()
    cache.set('key', 'value')
    assert cache.get('key') == 'value'
```

### Coverage Reporting

```bash
# Generate coverage report
pytest --cov=src --cov-report=html --cov-report=term-missing

# View in browser
open htmlcov/index.html

# Focus on untested error paths
# Red lines = not executed in tests
# Often error handling code!
```

---

## Related Topics

- **AP-23**: No Unit Tests - Need tests first
- **AP-15**: Swallowing Exceptions - Error handling issues

---

## Keywords

testing, error cases, edge cases, failure modes, test coverage, pytest, comprehensive testing

---

## Version History

- **2025-10-30**: Created - Added comprehensive error testing patterns

---

**File:** `AP-24.md`  
**Lines:** ~195  
**End of Document**
