# AP-06.md - God Objects

**REF-ID:** AP-06  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Topic:** Implementation  
**Priority:** üü† HIGH  
**Status:** Active  
**Created:** 2025-10-30  
**Last Updated:** 2025-10-30

---

## Summary

Creating massive classes or modules with too many responsibilities instead of focused, single-purpose implementations. God objects violate single responsibility principle and become unmaintainable.

---

## Context

Over time, convenience leads to adding "just one more method" to an existing class. Eventually, the class becomes a god object that handles everything, making it impossible to understand, test, or modify safely.

**Problem:** Violates single responsibility, creates tight coupling, blocks parallel development, increases merge conflicts.

---

## Content

### The Anti-Pattern

```python
# ‚ùå GOD OBJECT - Everything in one class
class SystemManager:
    def __init__(self):
        self.cache = {}
        self.logs = []
        self.metrics = {}
        self.http_sessions = []
        self.config = {}
        
    def cache_get(self, key): ...
    def cache_set(self, key, value): ...
    def log_info(self, msg): ...
    def log_error(self, msg): ...
    def record_metric(self, name, value): ...
    def make_http_request(self, url): ...
    def load_config(self): ...
    def validate_input(self, data): ...
    def format_response(self, data): ...
    # ... 50+ more methods across multiple domains
```

**Problems with this approach:**
- One class handling 5+ distinct responsibilities
- 2000+ lines in single file
- Impossible to understand fully
- Testing requires mocking entire massive object
- Every developer editing same file = merge conflicts
- Fear of breaking something prevents refactoring

### Why This Is Wrong

**1. Violates Single Responsibility Principle**
```python
# One class doing everything = one reason to change becomes many
# Cache logic changes? Edit SystemManager
# Logging changes? Edit SystemManager
# HTTP client changes? Edit SystemManager
# Config changes? Edit SystemManager
```

**2. Impossible to Test**
```python
# Must mock entire god object for every test
def test_cache_operation():
    mock_manager = Mock(SystemManager)
    # Must configure all 50+ methods even though
    # only testing cache_get()
    mock_manager.cache_get.return_value = "value"
    # Test becomes brittle and slow
```

**3. Team Paralysis**
```python
# 5 developers need to modify SystemManager
# Result: Constant merge conflicts
# Solution: Sequential development (slow)
# Or: Fear-based avoidance (technical debt)
```

**4. Cognitive Overload**
```python
# Human brain can hold ~7 concepts at once
# 50+ methods across 5 domains = impossible to understand
# Nobody knows what all methods do
# Side effects are hidden
# Dependencies are unclear
```

### Correct Approach

```python
# ‚úÖ FOCUSED MODULES - One responsibility each

# cache_manager.py (~150 lines)
class CacheManager:
    def get(self, key): ...
    def set(self, key, value): ...
    def delete(self, key): ...

# logger.py (~120 lines)
class Logger:
    def info(self, msg): ...
    def error(self, msg): ...
    def debug(self, msg): ...

# metrics_collector.py (~100 lines)
class MetricsCollector:
    def record(self, name, value): ...
    def get_stats(self): ...

# http_client.py (~180 lines)
class HttpClient:
    def get(self, url): ...
    def post(self, url, data): ...

# config_loader.py (~90 lines)
class ConfigLoader:
    def load(self): ...
    def validate(self): ...
```

**Benefits:**
- Each class has single, clear responsibility
- Easy to understand in isolation
- Simple to test independently
- Parallel development without conflicts
- Safe to refactor (small scope)
- Changes localized to relevant file

### Real-World Example

**Before (God Object):**
- `SystemCore` class: 2000+ lines
- Handled: cache, logging, HTTP, config, validation, formatting
- 5 developers = constant merge conflicts
- Testing = 30 minutes to set up mocks
- Refactoring = impossible (too risky)

**After (Focused Modules):**
- `cache_manager.py`: 280 lines
- `logger.py`: 220 lines  
- `http_client.py`: 350 lines
- `config_loader.py`: 180 lines
- `validator.py`: 150 lines
- `formatter.py`: 120 lines

**Results:**
- Developers work in parallel without conflicts
- Each module tested in < 5 minutes
- Refactoring safe (isolated changes)
- New developers understand purpose immediately
- Maintenance velocity increased 3x

### Detection

```bash
# Find large classes (>500 lines typically indicates god object)
grep -n "^class " **/*.py | while read line; do
    file=$(echo $line | cut -d: -f1)
    start=$(echo $line | cut -d: -f2)
    # Count lines until next class or EOF
    # Flag if > 500 lines
done

# Count methods per class
# More than 15-20 methods suggests god object
```

---

## Related Topics

- **AP-07**: Large Modules - God objects create large files
- **AP-20**: God Functions - Same problem at function level
- **ARCH-09**: Module Size Limits - Size constraints prevent god objects
- **DEC-17**: Flat File Structure - Multiple focused files vs nested god objects

---

## Keywords

god objects, single responsibility, SRP, focused modules, class design, maintainability, coupling, cohesion

---

## Version History

- **2025-10-30**: Created - Genericized from SUGA-ISP examples, added detection methods

---

**File:** `AP-06.md`  
**Lines:** ~185  
**End of Document**
