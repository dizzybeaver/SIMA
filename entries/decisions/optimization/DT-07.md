# DT-07.md

**REF-ID:** DT-07  
**Category:** Decision Logic  
**Subcategory:** Optimization  
**Name:** Should I Optimize This Code  
**Priority:** Medium  
**Status:** Active  
**Created:** 2024-10-30  
**Updated:** 2024-10-30

---

## Summary

Decision tree for optimization decisions ensuring measurements are taken first, code is on hot path, and optimization provides significant benefit without excessive complexity.

---

## Problem

Developers often optimize prematurely without measurements or focus on wrong areas. This leads to increased complexity with minimal performance gain, wasting time and reducing maintainability.

---

## Decision Tree

```
START: Considering optimization
│
├─ Q: Have you measured it?
│  ├─ NO → Measure first
│  │      Tools: time.time(), cProfile
│  │      Don't optimize without data
│  │      → END
│  │
│  └─ YES → Continue
│
├─ Q: Is it on critical path (hot path)?
│  ├─ NO → Don't optimize
│  │      Rationale: Not worth complexity
│  │      → END
│  │
│  └─ YES → Continue
│
├─ Q: What % of total time is it?
│  ├─ <5% → Don't optimize
│  │      Rationale: Small impact
│  │      → END
│  │
│  └─ >5% → Continue
│
├─ Q: Will optimization significantly complicate code?
│  ├─ YES → Reconsider
│  │      Trade-off: Complexity vs performance
│  │      Document if proceeding
│  │      → END or Continue
│  │
│  └─ NO → Continue
│
└─ Decision: Optimize
   Steps:
   1. Document current performance
   2. Implement optimization
   3. Measure improvement
   4. Document trade-offs
   5. Add performance test
   → END
```

---

## Examples

### Example 1: Premature Optimization (Don't Do)

**Scenario:** Optimizing without measurement

**Wrong Approach:**
```python
# ❌ Spending hours optimizing without knowing if it matters
def calculate_value(x):
    # Micro-optimization: using bitwise operations
    # instead of simple arithmetic
    result = (x << 1) + (x >> 2)  # Confusing
    return result
```

**Right Approach:**
```python
# âœ… Measure first, then decide
import time

start = time.time()
result = calculate_value(x)
duration = time.time() - start

# If <5% of total time → Don't optimize
# If >5% AND simple improvement → Optimize
```

### Example 2: Hot Path Optimization (Worth Doing)

**Scenario:** Function called 1000x per request, taking 50ms each

**Measurement:**
```python
# Function measured at 50ms, called 1000 times
# Total impact: 50,000ms (50 seconds per request!)
# This is 95% of total request time
# Priority: CRITICAL - optimize immediately
```

**Optimization:**
```python
# Before: O(n²) nested loops
def find_duplicates(items):
    duplicates = []
    for i, item in enumerate(items):
        for j, other in enumerate(items[i+1:]):
            if item == other:
                duplicates.append(item)
    return duplicates

# After: O(n) using set
def find_duplicates(items):
    seen = set()
    duplicates = set()
    for item in items:
        if item in seen:
            duplicates.add(item)
        seen.add(item)
    return list(duplicates)

# Result: 50ms → 0.5ms (100x improvement)
```

### Example 3: Cold Path (Don't Optimize)

**Scenario:** Initialization function called once per Lambda cold start

**Measurement:**
```python
# Function takes 10ms
# Called once per cold start (every ~5 minutes)
# Impact: 10ms / 300s = 0.003% of total time
# Priority: LOW - not worth optimizing
```

**Decision:**
```python
# âœ… Leave as-is, focus on hot paths
def initialize_system():
    # Simple, readable code
    # Performance here doesn't matter
    load_config()
    setup_logging()
    connect_services()
```

### Example 4: Borderline Case (Document Trade-off)

**Scenario:** Moderate performance gain but high complexity cost

**Analysis:**
```python
# Current: 60ms per operation
# Optimized: 40ms per operation (33% gain)
# Complexity: Would require significant refactoring
# Called: 50 times per request (2-3% of total time)

# Decision: DON'T optimize
# Rationale: 33% gain is good but:
# 1. Only 2-3% of total time
# 2. High complexity cost
# 3. Maintenance burden

# Instead: Document why it's slow
# PERFORMANCE NOTE: Intentionally simple O(n²) algorithm
# Measured: 60ms for typical input (n=100)
# Could optimize to O(n log n) with 33% gain
# Not worth complexity - only 2% of total request time
# Revisit if input size increases to n>500
```

### Example 5: Simple High-Impact Optimization

**Scenario:** Simple change with big impact

**Before:**
```python
# ❌ Rebuilding dispatch dict on every call
def handle_command(command_type):
    dispatch = {
        'start': start_handler,
        'stop': stop_handler,
        'status': status_handler,
        # 50 more handlers...
    }
    return dispatch.get(command_type)

# Measured: 2ms per call, called 500 times = 1000ms (20% of time)
```

**After:**
```python
# âœ… Move dispatch dict to module level
COMMAND_DISPATCH = {
    'start': start_handler,
    'stop': stop_handler,
    'status': status_handler,
    # 50 more handlers...
}

def handle_command(command_type):
    return COMMAND_DISPATCH.get(command_type)

# Measured: 0.01ms per call, called 500 times = 5ms (0.1% of time)
# Result: 1000ms → 5ms (200x improvement!)
# Complexity: Minimal (just moved dict)
```

---

## Related Patterns

**Decision Logic:**
- **DT-04**: Should This Be Cached (caching performance)
- **DT-10**: Should I Refactor This Code (refactoring decisions)
- **FW-01**: Cache vs Compute Trade-off Framework
- **FW-02**: Optimize or Document Trade-off Framework

**Anti-Patterns:**
- **AP-12**: Premature Optimization (what NOT to do)
- **AP-20**: Unnecessary Complexity (avoid complexity for no gain)

**Lessons:**
- **LESS-02**: Measure First Don't Guess (measurement importance)
- **LESS-17**: Performance Monitoring Patterns

**Decisions:**
- **DEC-13**: Fast Path Optimization (when/how to optimize hot paths)

---

## Keywords

optimization decision, performance measurement, hot path, premature optimization, complexity trade-off, profiling, bottleneck analysis, code efficiency, performance testing

---

## Version History

- **2024-10-30:** Migrated to SIMAv4 format from NM07 v3
- **2024-10-24:** Created in SIMAv3 format

---

**File:** `DT-07.md`  
**Location:** `/sima/entries/decisions/optimization/`  
**End of Document**
