# AP-08.md - Threading Locks in Single-Threaded Environments

**REF-ID:** AP-08  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Topic:** Concurrency  
**Priority:** üî¥ CRITICAL  
**Status:** Active  
**Created:** 2025-10-30  
**Last Updated:** 2025-10-30

---

## Summary

Using threading locks, queues, or synchronization primitives in single-threaded execution environments. These add overhead without benefit and indicate architectural misunderstanding.

---

## Context

When migrating code from multithreaded environments or copying patterns without understanding the execution model, developers add unnecessary synchronization. In single-threaded runtimes, locks provide zero protection while adding measurable overhead.

**Problem:** Wasted CPU cycles, code complexity, false sense of thread safety.

---

## Content

### The Anti-Pattern

```python
# ‚ùå THREADING IN SINGLE-THREADED ENVIRONMENT
import threading

lock = threading.Lock()
queue = threading.Queue()

def process_data(data):
    with lock:  # Unnecessary!
        result = expensive_operation(data)
    return result

def handle_request(request):
    queue.put(request)  # Unnecessary!
    return process_queue()
```

### Why This Is Wrong

**Single-Threaded Execution Model:**
- Each invocation runs in exactly one thread
- No concurrent access within single invocation
- Locks provide zero benefit
- Only add overhead and complexity

**Performance Impact:**
```
Lock acquisition: ~100ns
Lock release: ~100ns
Total overhead: ~200ns per operation

For 1000 operations:
- Wasted time: 200¬µs
- Plus mental overhead reviewing lock logic
- Plus code complexity from unnecessary synchronization
```

**False Security:**
```python
# Lock doesn't protect against real concurrency issues
# External state (databases, caches) needs different solutions
lock = threading.Lock()

def update_database(key, value):
    with lock:  # This doesn't help!
        # Database updates from other instances still race
        db.update(key, value)
```

### Common Execution Models

**Single-threaded environments:**
- AWS Lambda (each invocation = 1 thread)
- Cloud Functions
- Edge workers
- Event-driven systems
- Many serverless platforms

**Multi-threaded environments:**
- Traditional web servers (Django, Flask with threaded workers)
- Long-running services
- Desktop applications
- Multi-core processing applications

### Correct Approach

```python
# ‚úÖ NO LOCKS IN SINGLE-THREADED ENVIRONMENT
def process_data(data):
    # Direct processing - no synchronization needed
    result = expensive_operation(data)
    return result

# ‚úÖ USE EXTERNAL COORDINATION FOR CROSS-INVOCATION STATE
def update_counter():
    # Use atomic operations at storage layer
    current = cache.get("counter") or 0
    new_value = current + 1
    # Cache handles atomicity, not threading.Lock()
    cache.set("counter", new_value)
    return new_value
```

### Detection

```bash
# Find threading imports (should be ZERO in single-threaded env)
grep -r "import threading" src/
grep -r "from threading import" src/
grep -r "import asyncio" src/  # If not async environment
grep -r "from asyncio import" src/

# Check for threading primitives
grep -r "threading.Lock" src/
grep -r "threading.Queue" src/
grep -r "threading.Semaphore" src/
```

### Common Mistakes

**Mistake 1: Coming from multithreaded background**
```python
# Developer's previous code used locks
# Copy-paste without understanding new environment
```

**Mistake 2: Premature optimization**
```python
# "What if we add threading later?"
# YAGNI - You Aren't Gonna Need It
# Add complexity only when needed
```

**Mistake 3: Misunderstanding concurrency**
```python
# Thinks: "Multiple users = need locks"
# Reality: Multiple invocations = separate processes
# No shared memory between invocations
```

### When Threading IS Needed

**Multi-threaded web servers:**
```python
# Traditional Flask/Django with threaded workers
# Shared memory between requests in same process
lock = threading.Lock()

with lock:
    shared_resource.update()  # This IS needed here
```

**Long-running services:**
```python
# Background workers processing queue
# Multiple threads in same process
lock = threading.Lock()
```

**Rule:** Verify execution model before adding threading primitives.

---

## Related Topics

- **AP-11**: Race Conditions - Misunderstanding isolation
- **AP-13**: Multiprocessing - Similar issue with processes
- **DEC-04**: No Threading Locks - Design decision
- **LESS-06**: Single-Threaded Lesson - Learned from testing

---

## Keywords

threading, locks, single-threaded, concurrency, synchronization, Lambda, serverless, execution model

---

## Version History

- **2025-10-30**: Created - Genericized from Lambda-specific to any single-threaded environment

---

**File:** `AP-08.md`  
**Lines:** ~180  
**End of Document**
