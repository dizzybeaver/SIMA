# AP-17.md - Hardcoded Secrets

**REF-ID:** AP-17  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Topic:** Security  
**Priority:** 🔴 CRITICAL  
**Status:** Active  
**Created:** 2025-10-30  
**Last Updated:** 2025-10-30

---

## Summary

Hardcoding secrets (API keys, passwords, tokens, certificates) in source code. Major security vulnerability that exposes credentials in version control, logs, and code repositories.

---

## Context

Hardcoding secrets seems convenient during development but creates severe security risks when code is committed, deployed, or shared.

**Problem:** Credential exposure, compliance violations, security breaches, credential rotation nightmares.

---

## Content

### The Anti-Pattern

```python
# ❌ HARDCODED SECRETS
API_KEY = "sk-abc123def456789"
DB_PASSWORD = "MySecretPassword123!"
AWS_SECRET = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
PRIVATE_KEY = "-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIB..."

def connect_api():
    return requests.get(
        url,
        headers={"Authorization": f"Bearer {API_KEY}"}
    )
```

### Why This Is Critical

**1. Version Control Exposure**
```
Committed to Git → In history forever
Even if deleted later, exists in all clones
Anyone with repo access has credentials
```

**2. Log Exposure**
```python
# Logs often include variables
logger.debug(f"Config: API_KEY={API_KEY}")
# Credentials in logs → CloudWatch, Splunk, etc.
```

**3. Error Messages**
```python
try:
    connect(password=DB_PASSWORD)
except Exception as e:
    # Exception may include password value!
    logger.error(f"Connection failed: {e}")
```

**4. Rotation Nightmare**
```
Credential compromised → Must update code
Code update → Requires redeployment
Emergency rotation → System down during deploy
```

### Correct Approaches

**Environment Variables:**
```python
# ✅ ENVIRONMENT VARIABLES
import os

API_KEY = os.environ.get('API_KEY')
DB_PASSWORD = os.environ.get('DB_PASSWORD')

if not API_KEY:
    raise ValueError("API_KEY environment variable required")

def connect_api():
    return requests.get(
        url,
        headers={"Authorization": f"Bearer {API_KEY}"}
    )
```

**Configuration Files (not in repo):**
```python
# ✅ CONFIG FILE (add to .gitignore)
import json

with open('/etc/app/secrets.json') as f:
    secrets = json.load(f)

API_KEY = secrets['api_key']
DB_PASSWORD = secrets['db_password']
```

**Secrets Management Services:**
```python
# ✅ AWS SECRETS MANAGER
import boto3

def get_secret(secret_name):
    client = boto3.client('secretsmanager')
    response = client.get_secret_value(SecretId=secret_name)
    return json.loads(response['SecretString'])

secrets = get_secret('myapp/production')
API_KEY = secrets['api_key']
```

**Cloud Provider Parameter Stores:**
```python
# ✅ AWS SSM PARAMETER STORE
import boto3

ssm = boto3.client('ssm')

def get_parameter(name):
    response = ssm.get_parameter(
        Name=name,
        WithDecryption=True
    )
    return response['Parameter']['Value']

API_KEY = get_parameter('/myapp/api_key')
```

### Detection

```bash
# Scan for potential secrets
grep -rE "(password|passwd|pwd|secret|key|token|api_key)\s*=" src/
grep -rE "(sk-|pk-|AKIA)" src/  # Common API key patterns
grep -rE "-----BEGIN.*PRIVATE KEY-----" src/

# Use automated tools
git secrets --scan  # Scan git history
truffleHog --regex --entropy=False .  # Find secrets
detect-secrets scan  # Yelp's tool
```

### What Counts as a Secret

**Always protect:**
- API keys and tokens
- Passwords and passphrases
- Private keys and certificates
- Database connection strings (with passwords)
- OAuth client secrets
- Encryption keys
- Webhook secrets
- Session tokens
- Any authentication credentials

**Not secrets (can be in code):**
- Public API endpoints
- Public keys
- Usernames (without passwords)
- Non-sensitive configuration
- Algorithm names

### Migration Strategy

**Step 1: Identify all secrets**
```bash
# Audit codebase
grep -rE "(password|secret|key|token)" src/ > secrets_audit.txt
```

**Step 2: Move to secure storage**
```python
# For each secret:
# 1. Add to secrets manager
# 2. Update code to fetch
# 3. Test thoroughly
# 4. Remove from code
```

**Step 3: Clean git history (if exposed)**
```bash
# Use BFG Repo-Cleaner or git-filter-repo
bfg --replace-text passwords.txt  # Replace in history
git push --force
# Note: Anyone who cloned repo before this still has secrets!
# Must rotate all exposed credentials
```

**Step 4: Rotate compromised secrets**
```
Any secret in git history = compromised
Must generate new credentials
Update in secrets manager
Invalidate old credentials
```

### Best Practices

**Development:**
```python
# ✅ SEPARATE DEV AND PROD SECRETS
# dev.env (local only, not committed)
API_KEY=dev-key-safe-to-expose

# prod.env (managed by deployment, never in repo)
API_KEY=prod-key-must-be-secret
```

**CI/CD:**
```yaml
# ✅ SECRETS IN CI/CD VARIABLES
# .github/workflows/deploy.yml
env:
  API_KEY: ${{ secrets.API_KEY }}  # GitHub Secrets
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
```

**Docker:**
```dockerfile
# ✅ SECRETS AS BUILD ARGS OR RUNTIME ENV
# Don't bake secrets into image
FROM python:3.9
# Use runtime environment variables
CMD ["python", "app.py"]
```

**Documentation:**
```markdown
# ✅ DOCUMENT REQUIRED SECRETS
## Required Environment Variables
- `API_KEY`: API authentication key (obtain from service dashboard)
- `DB_PASSWORD`: Database password (stored in AWS Secrets Manager)
```

---

## Related Topics

- **AP-18**: Logging Sensitive Data - Related exposure risk
- **DEC-12**: Multi-Tier Configuration - Secure config management

---

## Keywords

hardcoded secrets, API keys, passwords, security, credentials, secrets management, SSM, environment variables

---

## Version History

- **2025-10-30**: Created - Generic patterns for any platform

---

**File:** `AP-17.md`  
**Lines:** ~195  
**End of Document**
