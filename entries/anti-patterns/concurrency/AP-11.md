# AP-11.md - Race Conditions in Isolated Environments

**REF-ID:** AP-11  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Topic:** Concurrency  
**Priority:** üü† HIGH  
**Status:** Active  
**Created:** 2025-10-30  
**Last Updated:** 2025-10-30

---

## Summary

Worrying about race conditions or concurrent access within isolated execution contexts. In containerized or serverless environments, invocations are isolated with no shared memory.

---

## Context

Developers familiar with traditional multi-threaded servers incorrectly assume race conditions exist in isolated execution environments. Understanding the isolation model prevents unnecessary complexity.

**Problem:** Unnecessary synchronization code, misplaced concerns, ignoring real concurrency issues.

---

## Content

### The Anti-Pattern

```python
# ‚ùå RACE CONDITION CONCERNS IN ISOLATED ENVIRONMENT
shared_counter = 0  # Module-level variable

def increment_counter():
    global shared_counter
    # Worried about race condition here?
    # This concern is misplaced in isolated environments
    shared_counter += 1
    return shared_counter

# Developer adds unnecessary protection
lock = threading.Lock()
def increment_counter_locked():
    with lock:  # Unnecessary - see AP-08
        global shared_counter
        shared_counter += 1
    return shared_counter
```

### Why This Is Wrong

**Isolated Execution Model:**
```
Invocation 1 (Container A): shared_counter = 1
Invocation 2 (Container B): shared_counter = 1  # Different container!
Invocation 3 (Container A): shared_counter = 2  # Reused Container A

Key insight: Each invocation either gets:
- Fresh container (variables reset)
- Reused container (variables from THAT container only)

No shared memory between different containers
= No race conditions within environment
```

**What Actually Happens:**
```python
# Time | Invocation | Container | Counter Value
# T0   | Inv-1      | A         | 0 ‚Üí 1
# T1   | Inv-2      | B         | 0 ‚Üí 1  (different container!)
# T2   | Inv-3      | A         | 1 ‚Üí 2  (reused A)
# T3   | Inv-4      | C         | 0 ‚Üí 1  (new container)

# Result: Counter is NOT shared
# Each container has its own memory space
```

### The Real Concurrency Issue

**Race conditions DO exist in external state:**
```python
# ‚úÖ CORRECT CONCERN - External state needs coordination
def increment_global_counter():
    # THIS has race conditions - multiple invocations
    # updating same database/cache key
    current = database.get("counter")
    new_value = current + 1
    database.set("counter", new_value)
    # ^ Race: Another invocation might update between get and set
```

### Correct Approach

**For in-memory state (within invocation):**
```python
# ‚úÖ NO LOCKS NEEDED - Single-threaded, isolated
local_counter = 0

def process_batch(items):
    local_counter = 0
    for item in items:
        process(item)
        local_counter += 1
    return local_counter
# No race conditions possible here
```

**For external state (between invocations):**
```python
# ‚úÖ USE ATOMIC OPERATIONS AT STORAGE LAYER
def increment_counter():
    # Use database/cache atomic operations
    new_value = cache.increment("counter")  # Atomic!
    return new_value

# ‚úÖ OR USE OPTIMISTIC LOCKING
def update_with_version(key, new_value):
    while True:
        current, version = cache.get_with_version(key)
        success = cache.set_if_version(key, new_value, version)
        if success:
            return new_value
        # Retry if version changed (another invocation updated)
```

### Common Environments

**Isolated execution (no race conditions within):**
- AWS Lambda
- Google Cloud Functions
- Azure Functions
- Docker containers (single-process mode)
- Kubernetes pods (single-process containers)

**Shared execution (race conditions possible):**
- Traditional web servers (threaded/multi-process)
- Shared memory systems
- Multi-threaded applications

### When Concurrency Matters

**Between invocations (external state):**
- Database updates
- Cache modifications
- File system writes
- External API calls with state

**Use these patterns:**
- Atomic operations (INCR, APPEND, etc.)
- Optimistic locking (version checks)
- Pessimistic locking (database locks)
- Transactions (ACID guarantees)
- Compare-and-swap operations

---

## Related Topics

- **AP-08**: Threading Locks - Related unnecessary synchronization
- **AP-13**: Multiprocessing - Similar isolation model
- **BUG-03**: Memory Leaks from Global State - Real issue with globals

---

## Keywords

race conditions, isolation, concurrency, serverless, containers, shared state, external state, atomic operations

---

## Version History

- **2025-10-30**: Created - Genericized from Lambda to any isolated environment

---

**File:** `AP-11.md`  
**Lines:** ~165  
**End of Document**
