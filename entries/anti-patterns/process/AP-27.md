# AP-27.md - Skipping Verification Protocol

**REF-ID:** AP-27  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Topic:** Process  
**Priority:** üü† HIGH  
**Status:** Active  
**Created:** 2025-10-30  
**Last Updated:** 2025-10-30

---

## Summary

Skipping systematic verification steps before implementing changes or providing code. Leads to anti-pattern violations, architectural inconsistencies, and preventable bugs.

---

## Context

Under time pressure, developers skip verification steps to move faster. Ironically, this creates bugs that waste far more time debugging and fixing than verification would have taken.

**Problem:** Preventable bugs, anti-pattern violations, architectural decay, technical debt accumulation.

---

## Content

### The Anti-Pattern

```
# ‚ùå NO VERIFICATION - Just implement

User: "Can I use threading locks for this?"
Developer: "Sure, here's the code:"
[Outputs code with threading.Lock()]

# Skipped verification steps:
# - Check execution environment (single-threaded?)
# - Check anti-patterns (AP-08: No threading locks)
# - Check architecture patterns (SUGA/MVC/etc)
# - Check existing solutions
# - Cite authoritative sources

# Result: Violated AP-08 (threading in single-threaded env)
```

### Why Verification Matters

**Statistics from real projects:**
```
Without verification:
- 30-40% of implementations violate anti-patterns
- 20-30% introduce architectural inconsistencies
- 50%+ miss existing solutions (duplicate code)
- Average debugging time: 2-4 hours per bug

With verification:
- <5% anti-pattern violations
- <5% architectural issues
- Minimal duplicate code
- Average verification time: 2-5 minutes

ROI: 5 minutes prevents 2-4 hours of debugging
```

### Standard Verification Protocol

**5-Step Verification (example):**

**Step 1: Read Complete Context**
```
- Load relevant documentation
- Read complete files (not snippets)
- Understand current implementation
- Identify dependencies
```

**Step 2: Verify Architecture Patterns**
```
- Check if solution fits architecture
- Verify layer boundaries respected
- Confirm patterns followed correctly
- Check for existing implementations
```

**Step 3: Check Anti-Patterns**
```
- Review relevant anti-pattern checklist
- Verify not violating critical patterns
- Check language-specific gotchas
- Confirm best practices followed
```

**Step 4: Verify Dependencies**
```
- Check import rules followed
- Verify no circular dependencies
- Confirm dependency layers respected
- Check for missing dependencies
```

**Step 5: Cite Authoritative Sources**
```
- Reference decision records
- Cite architecture documents
- Link to anti-pattern docs
- Provide REF-IDs for traceability
```

### Correct Approach

```
# ‚úÖ WITH VERIFICATION

User: "Can I use threading locks for this?"

Developer: 
[Step 3: Check anti-patterns]
- Checking concurrency anti-patterns...
- Found: AP-08 (Threading locks in single-threaded environments)
- Severity: CRITICAL
- Environment: AWS Lambda (single-threaded)
- Decision: DEC-04 (No threading primitives)

Response:
"NO - This environment uses single-threaded execution (AP-08).
Threading locks add overhead without benefit.

For synchronization between invocations, use:
- External locks (database locks)
- Atomic operations (cache INCR)
- Optimistic locking (version checks)

See: AP-08, DEC-04 for rationale."
```

### Verification Checklist Template

```markdown
## Pre-Implementation Verification

### Context
- [ ] Read relevant documentation
- [ ] Understand current implementation
- [ ] Identified dependencies
- [ ] Reviewed existing solutions

### Architecture
- [ ] Fits architectural patterns
- [ ] Layer boundaries respected
- [ ] No circular dependencies
- [ ] Follows established conventions

### Anti-Patterns
- [ ] Reviewed relevant AP list
- [ ] No critical violations
- [ ] No language gotchas
- [ ] Best practices followed

### Dependencies
- [ ] Import rules followed
- [ ] No new heavy dependencies
- [ ] Dependencies justified
- [ ] Versions compatible

### Documentation
- [ ] Changes documented
- [ ] Decisions recorded
- [ ] Tests planned
- [ ] Examples provided

**Time Required:** 2-5 minutes
**Bugs Prevented:** ~90% of common mistakes
```

### Project-Specific Verification

**For code reviews:**
```markdown
## Code Review Checklist
- [ ] Tests included
- [ ] Documentation updated
- [ ] No anti-patterns
- [ ] Performance considered
- [ ] Security reviewed
- [ ] Backward compatible
```

**For AI-assisted coding:**
```markdown
## AI Output Verification
- [ ] Code is complete (not truncated)
- [ ] All imports present
- [ ] No hallucinated functions
- [ ] Syntax is valid
- [ ] Logic is sound
- [ ] Error handling included
```

**For architectural changes:**
```markdown
## Architecture Change Checklist
- [ ] ADR created
- [ ] Impact analyzed
- [ ] Migration path defined
- [ ] Rollback plan exists
- [ ] Team reviewed
- [ ] Documentation updated
```

### Detection

**Signs verification was skipped:**
```python
# Anti-patterns in code
# Architectural violations
# Duplicate functionality
# Missing error handling
# No tests
# No documentation
```

**In code review:**
```
# Red flags:
- "Quick fix" without analysis
- Copy-pasted code without understanding
- Missing context about why
- No consideration of alternatives
- No tests for new code
```

### Cost-Benefit Analysis

**Verification cost:**
```
Time: 2-5 minutes per change
Effort: Low (checklist-driven)
Tools: Documentation, linters, checklists
```

**Bug cost (without verification):**
```
Detection: 1-2 days (production bug reports)
Debugging: 2-4 hours (root cause analysis)
Fixing: 1-2 hours (code changes)
Testing: 1 hour (regression testing)
Deployment: 30 minutes (emergency deploy)
Total: 4-8 hours minimum

+ Lost productivity from others
+ Customer impact
+ Reputation damage
```

**ROI:**
```
5 minutes verification
prevents
5-10 hours bug fixing
= 60-120x return on time invested
```

### Automation

**Automated checks:**
```bash
# Pre-commit hooks
pre-commit install

# Linting
flake8 src/
pylint src/

# Type checking
mypy src/

# Tests
pytest tests/

# Security
bandit -r src/
```

**CI/CD gates:**
```yaml
# .github/workflows/verify.yml
- name: Run verification
  run: |
    ./scripts/verify-anti-patterns.sh
    ./scripts/verify-architecture.sh
    ./scripts/verify-dependencies.sh
```

---

## Related Topics

- **AP-28**: Not Reading Complete Files - Related thorough verification
- **LESS-15**: 5-Step Verification Protocol - Specific example

---

## Keywords

verification, code review, quality assurance, anti-patterns, prevention, systematic process

---

## Version History

- **2025-10-30**: Created - Generic verification protocol

---

**File:** `AP-27.md`  
**Lines:** ~195  
**End of Document**
