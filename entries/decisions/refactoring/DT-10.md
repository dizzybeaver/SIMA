# DT-10.md

**REF-ID:** DT-10  
**Category:** Decision Logic  
**Subcategory:** Refactoring  
**Name:** Should I Refactor This Code  
**Priority:** Medium  
**Status:** Active  
**Created:** 2024-10-30  
**Updated:** 2024-10-30

---

## Summary

Decision tree for refactoring decisions, determining when code quality improvements justify the risk and effort based on correctness, readability, duplication, and architectural conformance.

---

## Problem

Refactoring improves code quality but introduces risk of bugs. Teams need clear criteria for when refactoring benefits outweigh costs of testing effort and potential issues.

---

## Decision Tree

```
START: Considering refactoring
│
├─ Q: Is code working correctly?
│  ├─ NO → Fix bugs first, then consider refactoring
│  │      Don't refactor broken code
│  │      → END
│  │
│  └─ YES → Continue
│
├─ Q: Is code hard to understand?
│  ├─ YES → Refactor for readability
│  │      Signs: Nested >3 levels, >50 lines, unclear names
│  │      → REFACTOR
│  │
│  └─ NO → Continue
│
├─ Q: Is code duplicated (>3 places)?
│  ├─ YES → Extract to function/utility
│  │      DRY principle: Don't Repeat Yourself
│  │      → REFACTOR
│  │
│  └─ NO → Continue
│
├─ Q: Is code violating architecture?
│  ├─ YES → Refactor to conform
│  │      Examples: Cross-interface imports, wrong layer
│  │      → REFACTOR
│  │
│  └─ NO → Continue
│
├─ Q: Is code significantly slow?
│  ├─ YES (measured) → Refactor for performance
│  │      See DT-07 for optimization decision
│  │      → REFACTOR
│  │
│  └─ NO → Continue
│
└─ Q: Is there a simpler way?
   ├─ YES (significantly simpler) → Consider refactoring
   │      Trade-off: Risk vs benefit
   │      → MAYBE REFACTOR
   │
   └─ NO → Don't refactor
          "If it ain't broke, don't fix it"
          → END
```

---

## Examples

### Example 1: Hard to Understand - REFACTOR

**Scenario:** Deeply nested conditional logic

**Before:**
```python
# ❌ Hard to understand - nested 4 levels
def process_request(request):
    if request:
        if request.get('type') == 'command':
            if request.get('status') == 'active':
                if request.get('priority') > 5:
                    return handle_high_priority(request)
                else:
                    return handle_normal_priority(request)
            else:
                return handle_inactive(request)
        else:
            return handle_non_command(request)
    else:
        return None
```

**After:**
```python
# âœ… Clear with early returns
def process_request(request):
    """Process request with clear early returns."""
    if not request:
        return None
    
    if request.get('type') != 'command':
        return handle_non_command(request)
    
    if request.get('status') != 'active':
        return handle_inactive(request)
    
    if request.get('priority', 0) > 5:
        return handle_high_priority(request)
    
    return handle_normal_priority(request)
```

**Benefit:** Reduced nesting from 4 to 0 levels, much easier to follow

### Example 2: Duplicated Code - REFACTOR

**Scenario:** Same pattern repeated 4 times

**Before:**
```python
# ❌ Duplicated pattern in 4 handlers
def handle_start():
    logger.log_info("Starting handler")
    setup_context()
    try:
        # Start logic here
        result = start_operation()
        return result
    finally:
        cleanup_context()
        logger.log_info("Handler complete")

def handle_stop():
    logger.log_info("Starting handler")
    setup_context()
    try:
        # Stop logic here
        result = stop_operation()
        return result
    finally:
        cleanup_context()
        logger.log_info("Handler complete")

# ... 2 more handlers with same pattern
```

**After:**
```python
# âœ… Extracted common pattern
def with_handler_context(handler_func):
    """Decorator providing common handler setup/teardown."""
    def wrapper(*args, **kwargs):
        logger.log_info("Starting handler")
        setup_context()
        try:
            return handler_func(*args, **kwargs)
        finally:
            cleanup_context()
            logger.log_info("Handler complete")
    return wrapper

@with_handler_context
def handle_start():
    """Start operation (context managed by decorator)."""
    return start_operation()

@with_handler_context
def handle_stop():
    """Stop operation (context managed by decorator)."""
    return stop_operation()
```

**Benefit:** DRY principle applied, single source of truth for pattern

### Example 3: Architecture Violation - REFACTOR

**Scenario:** Direct cross-interface import

**Before:**
```python
# ❌ In cache_core.py - violates RULE-01
from logging_core import log_info  # Direct cross-interface import

def cache_set(key, value):
    log_info(f"Setting cache key: {key}")  # Architecture violation
    return _internal_cache_set(key, value)
```

**After:**
```python
# âœ… Via gateway - conforms to architecture
from gateway import log_info  # Correct import path

def cache_set(key, value):
    log_info(f"Setting cache key: {key}")  # Via gateway
    return _internal_cache_set(key, value)
```

**Benefit:** Conforms to layered architecture, maintainable

### Example 4: Performance Issue - REFACTOR

**Scenario:** Measured bottleneck with O(n²) complexity

**Before:**
```python
# ❌ Slow: O(n²) nested loops
# Measured: 500ms for typical input (n=1000)
def find_common_items(list_a, list_b):
    """Find items present in both lists."""
    common = []
    for item_a in list_a:
        for item_b in list_b:
            if item_a == item_b:
                common.append(item_a)
    return common
```

**After:**
```python
# âœ… Fast: O(n) using set intersection
# Measured: 5ms for typical input (n=1000)
def find_common_items(list_a, list_b):
    """Find items present in both lists using set intersection."""
    return list(set(list_a) & set(list_b))
```

**Benefit:** 100x performance improvement with simpler code

### Example 5: Don't Refactor - Working Fine

**Scenario:** Code is clear, works well, but "could be better"

**Current Code:**
```python
# âœ… Current: Clear, works, tested
def calculate_score(base, multiplier, bonus):
    """Calculate score with multiplier and bonus."""
    result = base * multiplier
    if bonus:
        result += bonus
    return result

# Someone suggests: "We could make this more elegant"
def calculate_score_fancy(base, multiplier, bonus):
    """More 'elegant' version."""
    return base * multiplier + (bonus or 0)

# Decision: DON'T REFACTOR
# Rationale:
# - Current version is clear and tested
# - "Elegance" is subjective
# - No real benefit
# - Risk of introducing bugs
```

**Decision:** Don't refactor - "If it ain't broke, don't fix it"

---

## Related Patterns

**Decision Logic:**
- **DT-07**: Should I Optimize This Code (performance refactoring)
- **DT-11**: Extract to Function or Leave Inline (function extraction)
- **FW-02**: Optimize or Document Trade-off Framework

**Anti-Patterns:**
- **AP-20**: Unnecessary Complexity (avoid refactoring that adds complexity)
- **AP-21**: Inconsistent Patterns (fix with refactoring)
- **AP-22**: Missing Abstractions (identify with this decision tree)

**Lessons:**
- **LESS-01**: Read Complete Files First (before refactoring)
- **LESS-13**: Keep Functions Focused (refactoring goal)

**Rules:**
- **RULE-01**: Import via Gateway (architecture conformance)

---

## Keywords

refactoring decision, code quality, maintainability, readability, code duplication, DRY principle, architecture conformance, technical debt, code improvement, refactoring criteria

---

## Version History

- **2024-10-30:** Migrated to SIMAv4 format from NM07 v3
- **2024-10-24:** Created in SIMAv3 format

---

**File:** `DT-10.md`  
**Location:** `/sima/entries/decisions/refactoring/`  
**End of Document**
