# DT-02.md

**REF-ID:** DT-02  
**Category:** Decision Logic  
**Subcategory:** Import  
**Name:** Where Should Function Go  
**Priority:** High  
**Status:** Active  
**Created:** 2024-10-30  
**Updated:** 2024-10-30

---

## Summary

Decision tree for determining correct placement of new functions in gateway architecture - which layer (gateway/interface/core) and which interface based on functionality and dependencies.

---

## Problem

When creating new functionality, developers must decide where to place it in the three-layer architecture. Wrong placement creates maintenance issues, violates architecture patterns, and causes import problems.

---

## Context

Gateway architecture has three layers:
- **Gateway Layer:** Thin wrappers, routing only
- **Interface Layer:** Domain-specific routers, dispatch dictionaries
- **Core Layer:** Implementation logic, business rules

Functions must be placed in the correct layer and interface to maintain clean architecture.

---

## Decision Tree

```
START: Creating new function
│
├─ Q: Is this a simple wrapper/convenience function?
│  ├─ YES → Gateway wrappers
│  │      File: gateway_wrappers.py
│  │      Example: def cache_get(key): return call_interface(...)
│  │      → END
│  │
│  └─ NO → Continue
│
├─ Q: Does this route/dispatch to implementations?
│  ├─ YES → Interface router
│  │      File: interface_<name>.py
│  │      Example: _OPERATION_DISPATCH = {'get': _get, 'set': _set}
│  │      → END
│  │
│  └─ NO → Continue
│
├─ Q: Does this implement business logic?
│  ├─ YES → Core implementation
│  │      → Continue to interface selection
│  │
│  └─ NO → Utility function
│         File: utility_core.py
│         → END
│
└─ Q: Which interface does this belong to?
   ├─ Caching? → cache_core.py
   ├─ Logging? → logging_core.py
   ├─ Configuration? → config_core.py
   ├─ HTTP/Network? → http_core.py
   ├─ Metrics? → metrics_core.py
   ├─ Security? → security_core.py
   ├─ Initialization? → init_core.py
   ├─ Debugging? → debug_core.py
   ├─ Singleton? → singleton_core.py
   ├─ WebSocket? → websocket_core.py
   ├─ Circuit Breaker? → circuitbreaker_core.py
   └─ None fit? → utility_core.py or create new interface
      → END
```

---

## Layer Decision Matrix

| Function Type | Layer | File Pattern | Example |
|--------------|-------|--------------|---------|
| Thin wrapper | Gateway | gateway_wrappers.py | `def cache_get(key)` |
| Router/Dispatch | Interface | interface_<name>.py | `_OPERATION_DISPATCH = {...}` |
| Business logic | Core | <interface>_core.py | `def _execute_cache_set_implementation()` |
| Helper/Utility | Core | utility_core.py | `def format_timestamp()` |

---

## Interface Selection Guide

### Cache Interface (`cache_core.py`)
**Use for:**
- In-memory data storage
- TTL-based expiration
- Key-value operations
- Cache invalidation

**Examples:**
```python
def cache_set(key, value, ttl=300):
    """Store value in cache."""

def cache_get(key):
    """Retrieve value from cache."""

def cache_clear_expired():
    """Remove expired entries."""
```

### Logging Interface (`logging_core.py`)
**Use for:**
- Log message generation
- Log level management
- Structured logging
- Error reporting

**Examples:**
```python
def log_info(message, **context):
    """Log informational message."""

def log_error(message, error=None, **context):
    """Log error with context."""
```

### Configuration Interface (`config_core.py`)
**Use for:**
- Settings management
- Environment variables
- Configuration validation
- Multi-tier config (SSM, env vars)

**Examples:**
```python
def get_config(key, default=None):
    """Get configuration value."""

def validate_config(schema):
    """Validate configuration against schema."""
```

### HTTP Interface (`http_core.py`)
**Use for:**
- HTTP requests
- API calls
- Request retries
- Response handling

**Examples:**
```python
def http_get(url, headers=None):
    """Make HTTP GET request."""

def http_post(url, data, headers=None):
    """Make HTTP POST request."""
```

### Utility Interface (`utility_core.py`)
**Use for:**
- String manipulation
- Date/time formatting
- Data transformation
- Generic helpers

**Examples:**
```python
def format_timestamp(dt):
    """Format datetime as ISO string."""

def sanitize_string(text):
    """Remove special characters."""
```

---

## Examples

### Example 1: Gateway Wrapper

**Scenario:**
Create convenience function for cache operations

**Decision:**
- Simple wrapper? YES
- **Location:** gateway_wrappers.py

**Implementation:**
```python
# In gateway_wrappers.py
def cache_get(key: str):
    """Get value from cache.
    
    Convenience wrapper for gateway.call_interface().
    """
    return call_interface(
        interface=GatewayInterface.CACHE,
        operation='get',
        key=key
    )

def cache_set(key: str, value: Any, ttl: int = 300):
    """Set value in cache with TTL.
    
    Convenience wrapper for gateway.call_interface().
    """
    return call_interface(
        interface=GatewayInterface.CACHE,
        operation='set',
        key=key,
        value=value,
        ttl=ttl
    )
```

### Example 2: Interface Router

**Scenario:**
Add new operation to existing interface

**Decision:**
- Routes to implementation? YES
- **Location:** interface_cache.py

**Implementation:**
```python
# In interface_cache.py
_OPERATION_DISPATCH = {
    'get': _execute_get,
    'set': _execute_set,
    'delete': _execute_delete,
    'clear_expired': _execute_clear_expired,  # NEW operation
}

def _execute_clear_expired(parameters: Dict[str, Any]) -> Any:
    """Route clear_expired to core implementation."""
    from cache_core import clear_expired_entries
    return clear_expired_entries()
```

### Example 3: Core Implementation

**Scenario:**
Implement cache expiration logic

**Decision:**
- Business logic? YES
- Which interface? Cache
- **Location:** cache_core.py

**Implementation:**
```python
# In cache_core.py
from gateway import log_info, get_current_time

def clear_expired_entries():
    """Remove expired cache entries.
    
    Core implementation of cache expiration logic.
    """
    log_info("Starting cache expiration cleanup")
    current_time = get_current_time()
    removed_count = 0
    
    for key, entry in list(_CACHE_STORE.items()):
        if entry['expires_at'] < current_time:
            del _CACHE_STORE[key]
            removed_count += 1
    
    log_info(f"Cache cleanup complete: {removed_count} entries removed")
    return removed_count
```

### Example 4: Utility Function

**Scenario:**
Create timestamp formatting helper

**Decision:**
- Business logic? NO
- Generic utility? YES
- **Location:** utility_core.py

**Implementation:**
```python
# In utility_core.py
from datetime import datetime

def format_iso_timestamp(dt: datetime) -> str:
    """Format datetime as ISO 8601 string.
    
    Generic utility for timestamp formatting.
    """
    return dt.isoformat()

def parse_iso_timestamp(iso_str: str) -> datetime:
    """Parse ISO 8601 string to datetime.
    
    Generic utility for timestamp parsing.
    """
    return datetime.fromisoformat(iso_str)
```

---

## Anti-Patterns

### ❌ Wrong Layer Placement

**Problem:**
```python
# In interface_cache.py
def complex_cache_algorithm(data):
    """DON'T implement business logic in interface layer."""
    # 50 lines of complex logic here
    # WRONG - this belongs in core
```

**Solution:**
```python
# In interface_cache.py
def _execute_complex_operation(parameters):
    """Route to core implementation."""
    from cache_core import complex_cache_algorithm
    return complex_cache_algorithm(parameters['data'])

# In cache_core.py
def complex_cache_algorithm(data):
    """Implement complex logic in core layer."""
    # 50 lines of logic here - CORRECT location
```

### ❌ God Module

**Problem:**
```python
# In cache_core.py
def cache_set(): pass
def log_message(): pass  # WRONG - logging not cache
def send_http(): pass  # WRONG - HTTP not cache
```

**Solution:**
```python
# In cache_core.py
def cache_set(): pass  # CORRECT - cache function

# In logging_core.py
def log_message(): pass  # CORRECT - logging function

# In http_core.py
def send_http(): pass  # CORRECT - HTTP function
```

---

## Decision Flowchart

```
┌─────────────────────────────┐
│ Creating new function       │
└──────────┬──────────────────┘
           │
           ▼
    ┌──────────────┐
    │ Simple       │  YES ─► gateway_wrappers.py
    │ Wrapper?     │
    └──────┬───────┘
           │ NO
           ▼
    ┌──────────────┐
    │ Routing/     │  YES ─► interface_<name>.py
    │ Dispatch?    │
    └──────┬───────┘
           │ NO
           ▼
    ┌──────────────┐
    │ Business     │  YES ─► <interface>_core.py
    │ Logic?       │           (choose interface)
    └──────┬───────┘
           │ NO
           ▼
    ┌──────────────┐
    │ Generic      │  YES ─► utility_core.py
    │ Utility?     │
    └──────────────┘
```

---

## Related Patterns

**From NM01 (Interfaces):**
- **INT-01:** Cache Interface patterns
- **INT-02:** Config Interface patterns
- **INT-06:** Logging Interface patterns
- **INT-10:** Utility Interface patterns

**From NM02 (Dependencies):**
- **RULE-01:** Gateway imports for cross-interface
- **DEP-01 to DEP-05:** Dependency layers

**From NM04 (Decisions):**
- **DEC-01:** Gateway architecture choice
- **DEC-02:** Interface organization

**From NM05 (Anti-Patterns):**
- **AP-06:** God objects
- **AP-07:** Large modules

**From NM07 (Decision Logic):**
- **DT-01:** How to import functionality
- **DT-03:** User wants feature
- **DT-13:** Should I create new interface?

---

## Keywords

function placement, where to put code, layer selection, interface selection, code organization, architecture

---

## Version History

- **2024-10-30:** Migrated to SIMAv4 format from NM07 v3
- **2024-10-24:** Created in SIMAv3 format

---

**File:** `DT-02.md`  
**Location:** `/sima/entries/decision-logic/import/`  
**End of Document**
