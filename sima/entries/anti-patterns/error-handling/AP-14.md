# AP-14.md - Bare Except Clauses

**REF-ID:** AP-14  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Topic:** Error Handling  
**Priority:** üü† HIGH  
**Status:** Active  
**Created:** 2025-10-30  
**Last Updated:** 2025-10-30

---

## Summary

Using bare `except:` clauses without specifying exception types catches ALL exceptions including system signals, masking critical errors and making debugging impossible.

---

## Context

Writing `except:` without a type seems convenient for "catch everything," but it catches TOO much, including KeyboardInterrupt, SystemExit, and other signals that should propagate.

**Problem:** Masks system signals, hides real errors, violates fail-fast principle, debugging nightmare.

---

## Content

### The Anti-Pattern

```python
# ‚ùå BARE EXCEPT - Catches EVERYTHING
try:
    result = risky_operation()
except:  # NEVER do this!
    log_error("Something failed")
    return None
```

**What this catches:**
- KeyboardInterrupt (Ctrl+C)
- SystemExit (sys.exit())
- MemoryError
- ALL other exceptions
- Even typos in your error handling code!

### Why This Is Wrong

**1. Masks System Signals**
```python
# User presses Ctrl+C
try:
    long_running_operation()
except:  # Catches KeyboardInterrupt!
    pass  # User's interrupt ignored!
# Program continues when it should stop
```

**2. Hides Real Errors**
```python
try:
    result = calculate(data)
    process(result)
except:
    log_error("Something failed")  # Which line? What error?
    return None
# Lost all error context - impossible to debug
```

**3. Catches Errors in Error Handling**
```python
try:
    result = operation()
except:
    log.errr("Failed")  # Typo: errr instead of error
    # Bare except catches the typo!
    # Original error hidden by typo
```

### Exception Hierarchy

```python
BaseException  # Don't catch this level!
‚îú‚îÄ‚îÄ SystemExit
‚îú‚îÄ‚îÄ KeyboardInterrupt
‚îú‚îÄ‚îÄ GeneratorExit
‚îî‚îÄ‚îÄ Exception  # Catch THIS level or lower
    ‚îú‚îÄ‚îÄ StopIteration
    ‚îú‚îÄ‚îÄ ArithmeticError
    ‚îÇ   ‚îú‚îÄ‚îÄ FloatingPointError
    ‚îÇ   ‚îú‚îÄ‚îÄ OverflowError
    ‚îÇ   ‚îî‚îÄ‚îÄ ZeroDivisionError
    ‚îú‚îÄ‚îÄ AssertionError
    ‚îú‚îÄ‚îÄ AttributeError
    ‚îú‚îÄ‚îÄ BufferError
    ‚îú‚îÄ‚îÄ EOFError
    ‚îú‚îÄ‚îÄ ImportError
    ‚îú‚îÄ‚îÄ LookupError
    ‚îÇ   ‚îú‚îÄ‚îÄ IndexError
    ‚îÇ   ‚îî‚îÄ‚îÄ KeyError
    ‚îú‚îÄ‚îÄ NameError
    ‚îú‚îÄ‚îÄ OSError (IOError)
    ‚îú‚îÄ‚îÄ RuntimeError
    ‚îú‚îÄ‚îÄ TypeError
    ‚îî‚îÄ‚îÄ ValueError
```

**Rule:** Never catch above `Exception` level!

### Correct Approach

**Specific exceptions (best):**
```python
# ‚úÖ CATCH SPECIFIC EXCEPTIONS
try:
    result = risky_operation()
except ValueError as e:
    log_error(f"Invalid value: {e}")
    return None
except KeyError as e:
    log_error(f"Missing key: {e}")
    return None
except FileNotFoundError as e:
    log_error(f"File not found: {e}")
    raise  # Re-raise if can't handle
```

**Catch Exception (acceptable):**
```python
# ‚úÖ CATCH EXCEPTION - When truly unknown
try:
    result = risky_operation()
except Exception as e:  # Note: Exception, not bare except
    log_error(f"Unexpected error: {e}")
    raise  # Usually should re-raise
```

**Multiple exceptions:**
```python
# ‚úÖ MULTIPLE SPECIFIC EXCEPTIONS
try:
    data = load_config()
    validate(data)
    process(data)
except (IOError, OSError) as e:
    log_error(f"File error: {e}")
except ValueError as e:
    log_error(f"Validation error: {e}")
except Exception as e:
    log_error(f"Processing error: {e}")
    raise
```

### Detection

```bash
# Find bare except clauses
grep -rn "except:" src/ | grep -v "except Exception"
grep -rn "except  :" src/  # With space
grep -rn "except\s*:" src/  # Regex version

# Should return ZERO results in production code

# Use automated tools
# pylint will flag bare except as E722
pylint --errors-only src/
```

### Special Cases

**Only two acceptable bare except uses:**

1. **Cleanup-only (still bad, use finally instead):**
```python
# ‚ö†Ô∏è RARE CASE - But use finally instead!
try:
    resource = acquire()
    operation()
except:  # Catches everything
    # Only to ensure cleanup, then re-raise
    raise  # Must re-raise!
finally:
    release(resource)  # ‚úÖ Better - use finally

# ‚úÖ BETTER APPROACH:
try:
    resource = acquire()
    operation()
finally:
    release(resource)  # Always runs, no bare except needed
```

2. **Logging before re-raise (still bad):**
```python
# ‚ö†Ô∏è RARE CASE - But catch Exception instead!
try:
    operation()
except:
    log_error("Operation failed")  # Log it
    raise  # Must re-raise!

# ‚úÖ BETTER:
try:
    operation()
except Exception as e:  # Doesn't catch system signals
    log_error(f"Operation failed: {e}")
    raise
```

### Real-World Impact

**Before (bare except):**
```python
try:
    process_critical_data()
except:
    log.error("Failed")
    return None

# Result: 
# - User pressed Ctrl+C ‚Üí ignored
# - Out of memory ‚Üí hidden
# - Typo in code ‚Üí hidden
# - Impossible to debug production issues
```

**After (specific exceptions):**
```python
try:
    process_critical_data()
except ValueError as e:
    log.error(f"Invalid data: {e}")
    return None
except MemoryError as e:
    log.error(f"Out of memory: {e}")
    raise  # Let system handle
except Exception as e:
    log.error(f"Unexpected error: {e}")
    raise

# Result:
# - User Ctrl+C ‚Üí propagates (correct)
# - Out of memory ‚Üí logged and propagates
# - Clear error messages ‚Üí debuggable
# - Specific handling per error type
```

---

## Related Topics

- **AP-15**: Swallowing Exceptions - Related error hiding
- **AP-16**: No Error Context - Losing stack traces

---

## Keywords

bare except, exception handling, error masking, KeyboardInterrupt, SystemExit, fail-fast, debugging

---

## Version History

- **2025-10-30**: Created - Genericized with Python exception hierarchy

---

**File:** `AP-14.md`  
**Lines:** ~200  
**End of Document**
