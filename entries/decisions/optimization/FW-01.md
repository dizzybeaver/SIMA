# FW-01.md

**REF-ID:** FW-01  
**Category:** Decision Logic  
**Subcategory:** Optimization  
**Name:** Cache vs Compute Trade-off Framework  
**Priority:** Framework  
**Status:** Active  
**Created:** 2024-10-30  
**Updated:** 2024-10-30

---

## Summary

Mathematical framework for cache vs compute performance trade-offs, calculating expected benefit based on computation cost, cache overhead, and hit rates.

---

## Problem

Caching introduces overhead (lookup time, memory). Teams need quantitative method to determine when caching provides net benefit based on measurable parameters.

---

## Decision Tree

```
START: Should I cache or recompute?
│
├─ Calculate Parameters:
│  │
│  ├─ C = Computation cost (ms)
│  ├─ L = Lookup cost (ms, typically ~0.1ms)
│  └─ H = Hit rate (0-1, estimate from access pattern)
│
├─ Apply Formula:
│  │
│  └─ Benefit = (C - L) × H
│
├─ Evaluate Benefit:
│  │
│  ├─ Benefit > 5ms → CACHE (high benefit)
│  ├─ Benefit 1-5ms → CACHE (moderate benefit)
│  ├─ Benefit 0.5-1ms → BORDERLINE (context dependent)
│  └─ Benefit < 0.5ms → DON'T CACHE (overhead > benefit)
│
└─ END
```

---

## Examples

### Example 1: Clear Win for Caching

**Scenario:** Expensive API call

**Parameters:**
```
Computation cost (C) = 50ms
Lookup cost (L) = 0.1ms
Hit rate (H) = 80% (0.8)
```

**Calculation:**
```
Benefit = (C - L) × H
Benefit = (50 - 0.1) × 0.8
Benefit = 49.9 × 0.8
Benefit = 39.9ms per operation
```

**Decision:** **CACHE** - huge benefit (39.9ms savings)

**Implementation:**
```python
def get_api_data(key):
    # Check cache first
    cached = gateway.cache_get(f"api:{key}")
    if cached is not None:
        return cached
    
    # Cache miss - fetch from API
    data = expensive_api_call(key)
    
    # Cache with appropriate TTL
    gateway.cache_set(f"api:{key}", data, ttl=300)
    return data

# Benefit: 39.9ms per operation @ 80% hit rate
```

### Example 2: Borderline Case

**Scenario:** Simple calculation with moderate hit rate

**Parameters:**
```
Computation cost (C) = 2ms
Lookup cost (L) = 0.1ms
Hit rate (H) = 50% (0.5)
```

**Calculation:**
```
Benefit = (2 - 0.1) × 0.5
Benefit = 1.9 × 0.5
Benefit = 0.95ms per operation
```

**Decision:** **BORDERLINE** - context-dependent

**Considerations:**
```python
# If memory constrained → Don't cache
# If memory available → Cache

# Decision factors:
# 1. Lambda memory usage < 100MB? → Cache
# 2. Data size < 100KB? → Cache
# 3. Access frequency high? → Cache
# Otherwise → Don't cache

if memory_available and data_size_small and high_frequency:
    # Cache it
    cached = gateway.cache_get(key)
    if cached is None:
        cached = simple_compute(key)
        gateway.cache_set(key, cached, ttl=60)
    return cached
else:
    # Just compute
    return simple_compute(key)
```

### Example 3: Clear Loss

**Scenario:** Very fast operation with high hit rate

**Parameters:**
```
Computation cost (C) = 0.5ms
Lookup cost (L) = 0.1ms
Hit rate (H) = 90% (0.9)
```

**Calculation:**
```
Benefit = (0.5 - 0.1) × 0.9
Benefit = 0.4 × 0.9
Benefit = 0.36ms per operation
```

**Decision:** **DON'T CACHE** - overhead exceeds benefit

**Implementation:**
```python
# âœ… Don't cache - just compute
def fast_operation(x):
    return x * 2 + 10  # 0.5ms

# ❌ Wrong - caching adds overhead
def fast_operation_cached(x):
    cached = gateway.cache_get(f"fast:{x}")  # 0.1ms overhead
    if cached is None:
        cached = x * 2 + 10  # 0.5ms
        gateway.cache_set(f"fast:{x}", cached)  # 0.1ms overhead
    return cached
# Net result: Slower with cache!
```

### Example 4: Hit Rate Estimation

**Scenario:** Estimating cache effectiveness

**Access Pattern Analysis:**
```python
# Track access patterns
access_log = {}
for key in requests:
    access_log[key] = access_log.get(key, 0) + 1

# Calculate hit rate potential
total_accesses = sum(access_log.values())
repeat_accesses = sum(v - 1 for v in access_log.values() if v > 1)
estimated_hit_rate = repeat_accesses / total_accesses

# Example results:
# access_log = {'A': 5, 'B': 3, 'C': 1, 'D': 1}
# total_accesses = 10
# repeat_accesses = (5-1) + (3-1) = 6
# hit_rate = 6/10 = 60%
```

**Hit Rate Patterns:**
```
High hit rate (70-90%):
- Same data requested within TTL window
- User session data
- Configuration values
- Popular content

Medium hit rate (40-70%):
- Rotating popular data
- API responses with pagination
- Time-based data

Low hit rate (10-40%):
- Mostly unique requests
- User-specific one-time data
- Random queries
```

### Example 5: Decision Matrix Reference

**Quick lookup table:**

| Compute (C) | Lookup (L) | Hit Rate (H) | Benefit | Decision |
|-------------|------------|--------------|---------|----------|
| 50ms | 0.1ms | 80% | 39.9ms | CACHE |
| 50ms | 0.1ms | 50% | 25.0ms | CACHE |
| 50ms | 0.1ms | 20% | 10.0ms | CACHE |
| 10ms | 0.1ms | 80% | 7.9ms | CACHE |
| 10ms | 0.1ms | 50% | 5.0ms | CACHE |
| 5ms | 0.1ms | 80% | 3.9ms | CACHE |
| 2ms | 0.1ms | 80% | 1.5ms | CACHE |
| 2ms | 0.1ms | 50% | 0.95ms | BORDERLINE |
| 1ms | 0.1ms | 80% | 0.7ms | DON'T CACHE |
| 0.5ms | 0.1ms | 90% | 0.36ms | DON'T CACHE |

**Usage Example:**
```python
# User asks: "Cache 10ms operation with 60% hit rate?"
# Lookup: C=10ms, H=60% → Benefit ≈ 6ms → CACHE
```

---

## Related Patterns

**Decision Logic:**
- **DT-04**: Should This Be Cached (caching decision tree)
- **DT-07**: Should I Optimize This Code (optimization decisions)
- **FW-02**: Optimize or Document Trade-off Framework

**Decisions:**
- **DEC-09**: Cache Design Decisions (implementation patterns)
- **DEC-13**: Fast Path Optimization (performance patterns)

**Lessons:**
- **LESS-02**: Measure First Don't Guess (importance of measurement)
- **LESS-17**: Performance Monitoring Patterns

**Anti-Patterns:**
- **AP-12**: Premature Optimization (avoid caching without measurement)

---

## Keywords

cache vs compute, performance trade-off, hit rate calculation, caching benefit formula, optimization framework, cache overhead, computation cost, performance analysis

---

## Version History

- **2024-10-30:** Migrated to SIMAv4 format from NM07 v3
- **2024-10-24:** Created in SIMAv3 format

---

**File:** `FW-01.md`  
**Location:** `/sima/entries/decisions/optimization/`  
**End of Document**
