# File: AP-05.md

**REF-ID:** AP-05  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Type:** Import Violations  
**Severity:** ðŸ"´ Critical  
**Status:** Active

---

## SUMMARY

Importing anything from lambda_function.py (the Lambda entry point) into other modules. The entry point should import FROM modules, never the reverse.

---

## THE ANTI-PATTERN

### What NOT to Do

```python
# âŒ WRONG - Importing from lambda entry point

# In some_core.py
from lambda_function import lambda_handler, some_helper

def my_function():
    result = some_helper()
    return result
```

### Why It's Bad

1. **Circular Dependency at Entry** - Lambda entry is TOP of dependency tree
2. **Import Deadlock** - lambda_function imports your module, you import lambda_function
3. **Breaks Entry Point Pattern** - Entry points should be leaves, not branches
4. **Testing Nightmare** - Cannot import entry point in tests without side effects
5. **Initialization Order** - Undefined behavior, race conditions

---

## WHAT TO DO INSTEAD

### Correct Approach - Extract Shared Code

```python
# âœ… CORRECT - Extract shared code to utility module

# In utility_helpers.py (NEW FILE)
def some_helper():
    """Shared helper function."""
    return "result"

# In lambda_function.py
from utility_helpers import some_helper

def lambda_handler(event, context):
    result = some_helper()
    return result

# In some_core.py
from utility_helpers import some_helper

def my_function():
    result = some_helper()
    return result
```

### Why This Is Better

- No circular dependency
- Clear separation: entry point vs shared code
- Testable (can import utility without triggering Lambda)
- Follows standard entry point pattern
- Predictable initialization order

---

## THE ENTRY POINT PATTERN

### Correct Dependency Flow

```
lambda_function.py (TOP - depends on everything)
    â†"
gateway.py
    â†"
interface_*.py
    â†"
*_core.py (BOTTOM - depends on nothing above)
```

### Wrong Dependency Flow

```
lambda_function.py
    â†"
some_core.py
    â†'
lambda_function.py  # âŒ Circular!
```

### Rule

Entry points are **consumers**, not **providers**. They use modules but are never imported.

---

## REAL-WORLD EXAMPLE

### Context

Shared initialization code in lambda_function.py

### Problem Code

```python
# In lambda_function.py
def init_gateway():
    """Initialize gateway with config."""
    import gateway
    gateway.initialize()

def lambda_handler(event, context):
    init_gateway()
    # Handle request...

# In test_integration.py
from lambda_function import init_gateway  # Trying to reuse init!

def test_setup():
    init_gateway()  # Reuse Lambda's init
    # Run tests...
```

### What Went Wrong

```
Error: Unable to import module 'lambda_function': No module named 'lambda_runtime'
```

- Importing lambda_function in tests triggered AWS Lambda runtime expectations
- Tests tried to set up Lambda context
- Got error: missing Lambda runtime
- Tests failed because not running in Lambda environment

### Solution

```python
# In initialization_helpers.py (NEW FILE)
def init_gateway():
    """Initialize gateway with config."""
    import gateway
    gateway.initialize()

# In lambda_function.py
from initialization_helpers import init_gateway

def lambda_handler(event, context):
    init_gateway()
    # Handle request...

# In test_integration.py
from initialization_helpers import init_gateway

def test_setup():
    init_gateway()  # âœ… Works!
    # Run tests...
```

### Result

- Tests run successfully outside Lambda
- No circular dependencies
- Entry point stays clean
- Init code reusable everywhere

---

## AWS LAMBDA CONSIDERATIONS

### Lambda Entry Point Special Properties

- Lambda runtime imports it automatically
- Sets up AWS context (event, context parameters)
- May have environment-specific code
- Should be thin wrapper around actual logic

### Why Importing It Breaks Things

- Lambda runtime code executes on import
- AWS SDK initialization may fail outside Lambda
- Environment variables may not exist
- Context objects not available

### Best Practice

```python
# lambda_function.py should be minimal
from router import route_request

def lambda_handler(event, context):
    """AWS Lambda entry point - thin wrapper."""
    return route_request(event, context)
```

All actual logic in importable modules like `router.py`.

---

## HOW TO IDENTIFY

### Code Smells

- `from lambda_function import` anywhere
- Shared functions in lambda_function.py
- Tests that import lambda_function
- Circular import errors involving lambda_function

### Detection

```bash
# Find imports from lambda_function
grep -r "from lambda_function import" *.py

# Should return zero results!
```

### Test Indicator

If your tests import lambda_function, you're doing it wrong.

---

## MIGRATION GUIDE

### If You Have Shared Code in lambda_function.py

**Step 1:** Identify shared functions
```python
# Functions used by lambda_function AND other modules
```

**Step 2:** Create utility module
```bash
touch utility_lambda_helpers.py
```

**Step 3:** Move shared functions
```python
# Cut from lambda_function.py
# Paste into utility_lambda_helpers.py
```

**Step 4:** Update lambda_function.py
```python
from utility_lambda_helpers import shared_function

def lambda_handler(event, context):
    return shared_function(event)
```

**Step 5:** Update consuming modules
```python
# Change from:
from lambda_function import shared_function

# To:
from utility_lambda_helpers import shared_function
```

**Step 6:** Verify no imports from lambda_function
```bash
grep -r "from lambda_function import" *.py
# Should return nothing
```

**Step 7:** Test
```bash
python -m pytest tests/
```

---

## WHAT SHOULD BE IN LAMBDA_FUNCTION.PY

### Good (Minimal Entry Point)

```python
# lambda_function.py - MINIMAL
from router import route_request

def lambda_handler(event, context):
    """AWS Lambda entry point."""
    return route_request(event, context)
```

### Bad (Business Logic in Entry Point)

```python
# lambda_function.py - TOO MUCH!
import gateway

def init_system():
    """Initialize system."""
    gateway.initialize()

def process_event(event):
    """Process event."""
    # 50 lines of business logic...

def lambda_handler(event, context):
    init_system()
    return process_event(event)
```

### Rule of Thumb

**lambda_function.py should be < 20 lines and contain NO business logic.**

---

## IMPACT ANALYSIS

### Testing Impact

```
With imports from lambda_function:
- Tests fail outside Lambda environment
- Cannot mock Lambda context
- Side effects from import
- Test setup complicated

Without imports from lambda_function:
- Tests run anywhere
- Easy mocking
- Clean test setup
- Independent of Lambda runtime
```

### Maintenance Impact

```
With imports from lambda_function:
- Shared code mixed with entry point
- Hard to reuse logic
- Testing requires Lambda simulation

Without imports from lambda_function:
- Clear separation of concerns
- Reusable utility modules
- Easy testing
```

---

## RELATED PATTERNS

### Must Read First
- **DEC-01** - SUGA Pattern (entry point role)
- **ARCH-01** - Gateway Trinity

### Related Rules
- **Dependency Layers** - Lambda is Layer 9 (top)

### Related Anti-Patterns
- **AP-04** - Circular Imports
- **AP-01** - Direct Cross-Interface Imports

---

## DETECTION AND PREVENTION

### Code Review Checklist

- [ ] No `from lambda_function import` statements
- [ ] lambda_function.py < 20 lines
- [ ] No business logic in lambda_function.py
- [ ] Tests don't import lambda_function
- [ ] Shared code in utility modules

### Automated Detection

```python
def test_no_lambda_function_imports():
    """Verify nothing imports from lambda_function."""
    import os
    import re
    
    pattern = re.compile(r'from lambda_function import')
    
    for root, dirs, files in os.walk('src'):
        for file in files:
            if file.endswith('.py') and file != 'lambda_function.py':
                path = os.path.join(root, file)
                with open(path) as f:
                    content = f.read()
                    if pattern.search(content):
                        pytest.fail(f"AP-05 violation in {path}")
```

---

## SEVERITY JUSTIFICATION

### Why Critical

1. **Breaks Testing** - Cannot test outside Lambda
2. **Circular Dependency** - At system entry point
3. **Deployment Issues** - Lambda-specific dependencies leak
4. **Maintenance Cost** - Mixed concerns hard to maintain
5. **Architecture Violation** - Breaks entry point pattern

### Incident History

- **2025-10-15:** Test suite broken due to Lambda import
- **2025-09-20:** Circular dependency at entry point
- **2025-08-12:** Cannot run tests locally

**Total incidents:** 4 over 3 months  
**MTTR:** 30 minutes average  
**Prevention:** Keep lambda_function.py minimal

---

## KEYWORDS

lambda entry point, circular dependency, entry point pattern, AWS Lambda, import deadlock, testing, Lambda runtime

---

## VERSION HISTORY

### [1.0.0] - 2025-10-30
- Migrated to SIMAv4 format
- Added AWS Lambda considerations
- Added migration guide
- Enhanced testing guidance

### [0.9.0] - 2025-10-23
- SIMA v3 individual file format

### [0.1.0] - 2024-10-15
- Initial documentation

---

**END OF ANTI-PATTERN ENTRY**

**Related:** AP-01, AP-04, DEC-01, ARCH-01
