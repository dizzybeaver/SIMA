# DT-08.md

**REF-ID:** DT-08  
**Category:** Decision Logic  
**Subcategory:** Testing  
**Name:** What Should I Test  
**Priority:** High  
**Status:** Active  
**Created:** 2024-10-30  
**Updated:** 2024-10-30

---

## Summary

Decision tree for test coverage priorities - what must be tested, what should be tested, and what is optional based on feature complexity and risk.

---

## Problem

Comprehensive testing requires prioritization. Critical paths and error handling must be tested, while performance and load testing are optional depending on risk assessment.

---

## Test Priority Hierarchy

```
MUST TEST (Blocking):
├─ Success path (happy path)
├─ Failure path (error handling)
└─ Edge cases (boundary conditions)

SHOULD TEST (Recommended):
├─ Integration (cross-interface)
└─ Regression (prevent reintroduction)

OPTIONAL (Risk-based):
├─ Performance (time/memory bounds)
└─ Load/Stress (high volume)
```

---

## Decision Tree

```
START: Writing tests for feature X
│
├─ MUST TEST: Success path
│  Tests: Happy path, expected inputs
│  Coverage: Main functionality works
│  Priority: Critical
│
├─ MUST TEST: Failure path
│  Tests: Invalid inputs, errors
│  Coverage: Graceful error handling
│  Priority: Critical
│
├─ MUST TEST: Edge cases
│  Tests: Boundary values, empty inputs, None
│  Coverage: Corner cases handled
│  Priority: Critical
│
├─ SHOULD TEST: Integration
│  Tests: Cross-interface interactions
│  Coverage: Interfaces work together
│  Priority: High
│
├─ OPTIONAL: Performance
│  Tests: Time/memory bounds
│  Coverage: Performance regressions
│  Priority: Medium (if performance-critical)
│
└─ OPTIONAL: Load/Stress
   Tests: High volume, concurrent
   Coverage: System limits
   Priority: Low (unless high-traffic)
   → END
```

---

## Test Type Matrix

| Test Type | Priority | Example | When to Skip |
|-----------|----------|---------|--------------|
| Success path | MUST | `cache_get` returns value | Never |
| Failure path | MUST | `cache_get` returns None on miss | Never |
| Invalid input | MUST | `cache_set` raises on bad key | Never |
| Edge cases | MUST | `cache_get` with None key | Never |
| Integration | SHOULD | HTTP uses cache correctly | Simple functions only |
| Performance | OPTIONAL | `cache_get` <1ms | Non-critical paths |
| Load testing | OPTIONAL | 1000 operations/sec | Low-traffic features |

---

## Examples

### Example 1: MUST TEST - Success Path

**Feature:** Cache get operation

**Test:**
```python
def test_cache_get_success():
    """Test successful cache retrieval."""
    # Setup
    gateway.cache_set("test_key", "test_value")
    
    # Execute
    result = gateway.cache_get("test_key")
    
    # Verify
    assert result == "test_value"
```

### Example 2: MUST TEST - Failure Path

**Feature:** Cache get with miss

**Test:**
```python
def test_cache_get_miss():
    """Test cache miss returns None."""
    # Execute (key doesn't exist)
    result = gateway.cache_get("nonexistent_key")
    
    # Verify
    assert result is None

def test_cache_set_invalid_key():
    """Test invalid key raises ValueError."""
    # Execute and verify
    with pytest.raises(ValueError):
        gateway.cache_set("", "value")  # Empty key
```

### Example 3: MUST TEST - Edge Cases

**Feature:** Cache operations with boundary conditions

**Test:**
```python
def test_cache_edge_cases():
    """Test edge cases and boundary conditions."""
    # None key
    with pytest.raises(ValueError):
        gateway.cache_get(None)
    
    # Empty string key
    with pytest.raises(ValueError):
        gateway.cache_set("", "value")
    
    # None value (should work)
    gateway.cache_set("key", None)
    assert gateway.cache_get("key") is None
    
    # Very long key
    long_key = "x" * 1000
    gateway.cache_set(long_key, "value")
    assert gateway.cache_get(long_key) == "value"
    
    # TTL of 0
    gateway.cache_set("key", "value", ttl=0)
    # Should expire immediately or raise
```

### Example 4: SHOULD TEST - Integration

**Feature:** HTTP using cache

**Test:**
```python
def test_http_with_cache_integration():
    """Test HTTP client uses cache correctly."""
    # First request (cache miss)
    response1 = http_get_cached("https://api.example.com/data")
    
    # Second request (cache hit)
    response2 = http_get_cached("https://api.example.com/data")
    
    # Verify same response
    assert response1 == response2
    
    # Verify cache was used (check cache directly)
    cached = gateway.cache_get("http:https://api.example.com/data")
    assert cached == response1
```

### Example 5: OPTIONAL - Performance

**Feature:** Cache get performance

**Test:**
```python
import time

def test_cache_performance():
    """Test cache get performance."""
    # Setup
    gateway.cache_set("perf_test", "value")
    
    # Measure
    start = time.time()
    for _ in range(1000):
        gateway.cache_get("perf_test")
    duration = time.time() - start
    
    # Verify (<1ms per operation = 1s for 1000)
    assert duration < 1.0, f"Too slow: {duration}s for 1000 operations"
```

### Example 6: OPTIONAL - Load Testing

**Feature:** Cache under load

**Test:**
```python
import concurrent.futures

def test_cache_load():
    """Test cache under concurrent load."""
    def cache_operation(i):
        gateway.cache_set(f"key_{i}", f"value_{i}")
        return gateway.cache_get(f"key_{i}")
    
    # 100 concurrent operations
    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
        results = list(executor.map(cache_operation, range(100)))
    
    # Verify all succeeded
    assert len(results) == 100
    assert all(r is not None for r in results)
```

---

## Test Coverage Goals

### Critical Functions (100% Coverage)
- Gateway wrappers
- Core business logic
- Error handling paths
- Validation functions

### Important Functions (80%+ Coverage)
- Interface routers
- Utility functions
- Helper functions

### Low Priority (50%+ Coverage)
- Simple getters/setters
- Trivial wrappers
- Deprecated code

---

## Anti-Patterns

### ❌ Testing Only Success Path

**Problem:**
```python
def test_cache():
    """Only tests happy path."""
    gateway.cache_set("key", "value")
    assert gateway.cache_get("key") == "value"
    # Missing: error cases, edge cases
```

**Solution:**
```python
def test_cache_success():
    """Test success path."""
    gateway.cache_set("key", "value")
    assert gateway.cache_get("key") == "value"

def test_cache_miss():
    """Test failure path."""
    assert gateway.cache_get("nonexistent") is None

def test_cache_invalid_key():
    """Test error handling."""
    with pytest.raises(ValueError):
        gateway.cache_set("", "value")
```

### ❌ No Edge Case Testing

**Problem:**
```python
def test_process_list():
    """Only tests normal list."""
    result = process_list([1, 2, 3])
    assert result == [2, 4, 6]
    # Missing: empty list, None, single item
```

**Solution:**
```python
def test_process_list_normal():
    assert process_list([1, 2, 3]) == [2, 4, 6]

def test_process_list_empty():
    assert process_list([]) == []

def test_process_list_single():
    assert process_list([5]) == [10]

def test_process_list_none():
    with pytest.raises(TypeError):
        process_list(None)
```

---

## Related Patterns

**From NM04 (Decisions):**
- **DEC-18:** Test strategy decisions

**From NM05 (Anti-Patterns):**
- **AP-23:** No unit tests
- **AP-24:** Testing only success paths

**From NM06 (Lessons):**
- **LESS-08:** Test failure paths

**From NM07 (Decision Logic):**
- **DT-09:** How much to mock

---

## Keywords

testing, test coverage, unit tests, integration tests, test priorities, what to test, test strategy

---

## Version History

- **2024-10-30:** Migrated to SIMAv4 format from NM07 v3
- **2024-10-24:** Created in SIMAv3 format

---

**File:** `DT-08.md`  
**Location:** `/sima/entries/decisions/testing/`  
**End of Document**
