# AP-19.md - Sentinel Objects Crossing Boundaries

**REF-ID:** AP-19  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Topic:** Security  
**Priority:** üî¥ CRITICAL  
**Status:** Active  
**Created:** 2025-10-30  
**Last Updated:** 2025-10-30

---

## Summary

Allowing internal sentinel objects (like `_CacheMiss`, `_NotFound`, `_Empty`) to leak across module boundaries. These objects can cause serialization failures, unexpected behavior, and severe performance penalties.

---

## Context

Sentinel objects are internal markers used to distinguish "not found" from `None`. When they leak outside their module, external code doesn't know how to handle them, causing failures.

**Problem:** Serialization failures, type confusion, performance penalties, brittle cross-module contracts.

---

## Content

### The Anti-Pattern

```python
# ‚ùå SENTINEL LEAKING ACROSS MODULE BOUNDARY

# In cache_module.py
_CacheMiss = object()  # Internal sentinel

def get_value(key):
    if key not in _CACHE:
        return _CacheMiss  # Sentinel leaks out!
    return _CACHE[key]

# In application_code.py
result = cache_module.get_value(key)
if result is None:  # Wrong check!
    handle_miss()
else:
    # Sentinel passes through as truthy value!
    return result  # Returns _CacheMiss object!
```

### Real-World Impact

**Serialization failure:**
```python
# Sentinel leaks to JSON serialization
result = get_value(key)  # Returns _CacheMiss
response = json.dumps({"value": result})
# TypeError: Object of type 'object' is not JSON serializable
```

**Performance penalty:**
```python
# Real incident: 535ms added latency
# Sentinel object attempted serialization
# Fallback serializers triggered
# Multiple retry attempts
# Total: 535ms per request
# Impact: 100% of traffic affected
```

**Type confusion:**
```python
# Caller expects string or None
result = get_value(key)
if isinstance(result, str):
    process_string(result)
elif result is None:
    handle_none()
else:
    # Unexpected path - what is this object?
    # Causes TypeError later
```

### Why This Happens

**1. Private Sentinels Not Documented**
```python
# Developer doesn't know sentinel exists
# Checks only for None
# Sentinel slips through
```

**2. Identity Checks Are Brittle**
```python
# Sentinel is identity-based
# Only works with `is` operator
# `==` checks don't help
# Easy to miss in code review
```

**3. Multiple Modules**
```python
# Module A returns _CacheMiss
# Module B doesn't know about it
# Module C tries to serialize it
# Failure far from source
```

### Correct Approach (Sanitize at Boundary)

```python
# ‚úÖ SANITIZE AT MODULE BOUNDARY

# In cache_module.py (internal)
_CacheMiss = object()  # Private sentinel

def _get_value_internal(key):
    """Internal function - may return sentinel."""
    if key not in _CACHE:
        return _CacheMiss
    return _CACHE[key]

# PUBLIC API - Sanitizes sentinel
def get_value(key, default=None):
    """
    Get value from cache.
    
    Args:
        key: Cache key
        default: Value to return if key not found
        
    Returns:
        Cached value or default (never returns sentinel)
    """
    result = _get_value_internal(key)
    if result is _CacheMiss:
        return default  # Sanitized!
    return result

# Now safe for external use
result = cache_module.get_value(key)
if result is None:  # Correct check
    handle_miss()
```

**Alternative: Exception for Not Found**
```python
# ‚úÖ USE EXCEPTION INSTEAD OF SENTINEL

class CacheMissError(Exception):
    """Raised when key not found in cache."""
    pass

def get_value(key):
    """
    Get value from cache.
    
    Raises:
        CacheMissError: If key not found
    """
    if key not in _CACHE:
        raise CacheMissError(f"Key '{key}' not found")
    return _CACHE[key]

# Usage is explicit
try:
    result = cache_module.get_value(key)
    process(result)
except CacheMissError:
    handle_miss()
```

**Alternative: Return Tuple**
```python
# ‚úÖ RETURN (FOUND, VALUE) TUPLE

def get_value(key):
    """
    Get value from cache.
    
    Returns:
        Tuple[bool, Any]: (found, value)
        - found=True, value=cached value
        - found=False, value=None
    """
    if key not in _CACHE:
        return (False, None)
    return (True, _CACHE[key])

# Usage is explicit
found, result = cache_module.get_value(key)
if found:
    process(result)
else:
    handle_miss()
```

### Sentinel Design Rules

**Rule 1: Private to Module**
```python
# ‚úÖ Sentinel is private (leading underscore)
_CacheMiss = object()

# ‚ùå Don't export
__all__ = ['get_value']  # _CacheMiss not in public API
```

**Rule 2: Never Return Directly**
```python
# ‚úÖ Sanitize in public functions
def get_value(key, default=None):
    result = _internal_get(key)
    return default if result is _CacheMiss else result

# ‚ùå Never return sentinel
def get_value(key):
    return _CACHE.get(key, _CacheMiss)  # BAD!
```

**Rule 3: Check Before Returning**
```python
# ‚úÖ Verify no sentinel in return value
def get_batch(keys):
    results = []
    for key in keys:
        value = _internal_get(key)
        if value is not _CacheMiss:
            results.append(value)
    return results  # No sentinels in result
```

**Rule 4: Document Sentinel Existence**
```python
# ‚úÖ Document for internal developers
"""
Internal Note: This module uses _CacheMiss sentinel.
All public functions MUST sanitize before returning.
Never return sentinel to external code.
"""
```

### Detection

```bash
# Find sentinel definitions
grep -rn "= object()" src/

# Find potential leaks (returns sentinel)
grep -rn "return _.*Miss" src/
grep -rn "return _.*Empty" src/
grep -rn "return _.*Sentinel" src/

# Review public API functions
# Ensure all check for sentinels before returning
```

### Testing Sentinel Sanitization

```python
# ‚úÖ TEST THAT SENTINELS DON'T LEAK

def test_cache_miss_returns_none():
    """Verify sentinel is sanitized to None."""
    result = get_value("nonexistent_key")
    assert result is None  # Not sentinel
    assert type(result).__name__ != 'object'  # Not bare object

def test_cache_miss_with_default():
    """Verify default is returned, not sentinel."""
    default_value = "default"
    result = get_value("nonexistent_key", default=default_value)
    assert result == default_value
    assert result is not None

def test_result_is_json_serializable():
    """Verify no sentinel in serialization."""
    result = get_value("any_key")
    # Should not raise TypeError
    json_str = json.dumps({"value": result})
    assert isinstance(json_str, str)
```

---

## Related Topics

- **BUG-01**: Sentinel Leak - Real 535ms incident
- **DEC-05**: Sentinel Sanitization - Design decision
- **AP-10**: Mutable Defaults - Related pitfall

---

## Keywords

sentinel objects, boundary sanitization, _CacheMiss, object leaking, serialization, module boundaries

---

## Version History

- **2025-10-30**: Created - Genericized from specific incident, added alternatives

---

**File:** `AP-19.md`  
**Lines:** ~195  
**End of Document**
