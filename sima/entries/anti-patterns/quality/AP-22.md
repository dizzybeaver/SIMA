# File: AP-22.md

**REF-ID:** AP-22  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Type:** Quality  
**Severity:** âšª Low  
**Status:** Active

---

## SUMMARY

Inconsistent naming conventions mixing styles (camelCase, snake_case, PascalCase). Creates confusion and reduces code readability.

---

## THE ANTI-PATTERN

```python
# âŒ MIXED NAMING STYLES
class myClass:  # Should be MyClass
    def GetValue(self):  # Should be get_value
        return self.dataValue  # Should be data_value
        
def ProcessData(InputValue):  # Should be process_data, input_value
    return InputValue * 2
```

---

## WHAT TO DO INSTEAD

```python
# âœ… PEP 8 NAMING
class MyClass:  # PascalCase for classes
    def get_value(self):  # snake_case for methods
        return self.data_value  # snake_case for attributes
        
def process_data(input_value):  # snake_case for functions and params
    return input_value * 2
```

---

## PEP 8 CONVENTIONS

| Type | Convention | Example |
|------|------------|---------|
| Module | snake_case | cache_core.py |
| Class | PascalCase | CacheManager |
| Function | snake_case | get_value() |
| Method | snake_case | self.process() |
| Variable | snake_case | result_data |
| Constant | UPPER_SNAKE | MAX_SIZE |
| Private | _prefix | _internal_method() |

---

## DETECTION

```bash
# Lint with flake8
flake8 --select=N src/

# Lint with pylint
pylint --disable=all --enable=invalid-name src/
```

---

## RELATED

- **AP-20** - God Functions
- **AP-21** - Magic Numbers

---

**Keywords:** naming conventions, PEP 8, code style, readability

---

**END OF AP-22**

---

# File: Quality-Index.md

**Category:** Anti-Patterns  
**Topic:** Quality  
**Items:** 3  
**Version:** 1.0.0

---

## FILES

### AP-20: God Functions (>50 lines)
- **Severity:** ðŸŸ¡ Medium
- **Problem:** Functions too long, multiple responsibilities
- **Solution:** Split into focused functions < 50 lines

### AP-21: Magic Numbers
- **Severity:** ðŸŸ¡ Medium
- **Problem:** Unexplained numeric literals
- **Solution:** Named constants with documentation

### AP-22: Inconsistent Naming
- **Severity:** âšª Low
- **Problem:** Mixed naming styles
- **Solution:** Follow PEP 8 consistently

---

**Common Theme:** Code clarity and maintainability. Technical debt accumulation.

---

**Keywords:** code quality, maintainability, clean code

**END OF INDEX**

---

# File: AP-23.md

**REF-ID:** AP-23  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Type:** Testing  
**Severity:** ðŸŸ  High  
**Status:** Active

---

## SUMMARY

Deploying code without unit tests. Makes refactoring dangerous and hides bugs until production.

---

## THE ANTI-PATTERN

```python
# âŒ NO TESTS
def calculate_total(items):
    total = 0
    for item in items:
        total += item['price'] * item['quantity']
    return total

# Deployed without any tests!
```

---

## WHAT TO DO INSTEAD

```python
# âœ… WITH TESTS
def calculate_total(items):
    total = 0
    for item in items:
        total += item['price'] * item['quantity']
    return total

# test_calculations.py
def test_calculate_total():
    items = [
        {'price': 10.0, 'quantity': 2},
        {'price': 5.0, 'quantity': 3}
    ]
    assert calculate_total(items) == 35.0
    
def test_calculate_total_empty():
    assert calculate_total([]) == 0
```

---

## MINIMUM TEST COVERAGE

**Required:**
- Happy path (success case)
- Edge cases (empty, null, boundary)
- Error cases (invalid input)

**For Each Function:**
- At least 3 test cases
- Cover main branches
- Test error handling

---

## DETECTION

```bash
# Check test coverage
pytest --cov=src tests/
pytest --cov-report=html

# Fail if < 80% coverage
pytest --cov=src --cov-fail-under=80
```

---

## RELATED

- **AP-24** - Testing Only Success Paths

---

**Keywords:** testing, unit tests, test coverage, TDD

---

**END OF AP-23**

---

# File: AP-24.md

**REF-ID:** AP-24  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Type:** Testing  
**Severity:** ðŸŸ  High  
**Status:** Active

---

## SUMMARY

Writing tests that only verify success paths, ignoring error cases. Leaves bugs hidden in error handling.

---

## THE ANTI-PATTERN

```python
# âŒ ONLY SUCCESS PATH
def test_process_data():
    result = process_data({"valid": "data"})
    assert result == "success"
    
# Missing:
# - What if data is None?
# - What if data is malformed?
# - What if processing fails?
```

---

## WHAT TO DO INSTEAD

```python
# âœ… TEST SUCCESS AND FAILURES
def test_process_data_success():
    result = process_data({"valid": "data"})
    assert result == "success"
    
def test_process_data_none():
    with pytest.raises(ValueError):
        process_data(None)
        
def test_process_data_malformed():
    with pytest.raises(ValueError):
        process_data({"invalid": "structure"})
        
def test_process_data_empty():
    result = process_data({})
    assert result == "default"
```

---

## TEST CHECKLIST

**For Each Function Test:**
- [ ] Success case
- [ ] None input
- [ ] Empty input
- [ ] Invalid input
- [ ] Boundary conditions
- [ ] Error handling

---

## RELATED

- **AP-23** - No Unit Tests
- **AP-15** - Swallowing Exceptions

---

**Keywords:** testing, error cases, edge cases, test coverage

---

**END OF AP-24**

---

# File: Testing-Index.md

**Category:** Anti-Patterns  
**Topic:** Testing  
**Items:** 2  
**Version:** 1.0.0

---

## FILES

### AP-23: No Unit Tests
- **Severity:** ðŸŸ  High
- **Problem:** Code deployed without tests
- **Solution:** Minimum 80% coverage, test main paths

### AP-24: Testing Only Success Paths
- **Severity:** ðŸŸ  High
- **Problem:** Ignoring error cases in tests
- **Solution:** Test success, errors, edge cases

---

**Common Theme:** Comprehensive testing prevents production bugs.

---

**Keywords:** testing, unit tests, error cases

**END OF INDEX**

---

# File: AP-25.md

**REF-ID:** AP-25  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Type:** Documentation  
**Severity:** ðŸŸ  High  
**Status:** Active

---

## SUMMARY

Making design decisions without documenting the rationale. Future developers don't understand why choices were made.

---

## THE ANTI-PATTERN

```python
# âŒ NO DOCUMENTATION
def process_batch(items):
    # Why batch size of 100?
    # Why this specific algorithm?
    # Why not use library X?
    # Nobody knows!
    for i in range(0, len(items), 100):
        batch = items[i:i+100]
        process(batch)
```

---

## WHAT TO DO INSTEAD

```python
# âœ… DOCUMENT DECISIONS
# DEC-24: Batch size = 100
# Rationale: Tested batch sizes 10, 50, 100, 200, 500
# 100 provides best balance:
# - Memory: < 10MB per batch
# - Performance: 2.5s per batch (acceptable)
# - Error recovery: Limited blast radius
# See: Performance Testing Results (2025-10-15)

def process_batch(items):
    BATCH_SIZE = 100  # See DEC-24
    for i in range(0, len(items), BATCH_SIZE):
        batch = items[i:i+BATCH_SIZE]
        process(batch)
```

---

## WHEN TO DOCUMENT

**Document These Decisions:**
- Architecture choices
- Algorithm selections
- Library choices
- Performance trade-offs
- Security decisions
- Error handling strategies

**In Neural Maps:**
- Create DEC-## entry
- Explain context, options, choice
- Document reasoning
- Record date and author

---

## RELATED

- **DEC-01** through **DEC-23** - Existing decisions
- **AP-26** - Stale Comments
- **DEC-19** - Neural Map Documentation

---

**Keywords:** documentation, decisions, rationale, neural maps

---

**END OF AP-25**

---

# File: AP-26.md

**REF-ID:** AP-26  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Type:** Documentation  
**Severity:** ðŸŸ¡ Medium  
**Status:** Active

---

## SUMMARY

Comments that contradict the code, becoming outdated as code evolves. Worse than no comments - actively misleading.

---

## THE ANTI-PATTERN

```python
# âŒ STALE COMMENTS
# Returns list of active users
def get_users():
    # Code was refactored - now returns dict, not list!
    return {"users": [...], "count": 10}

# Cached for 5 minutes
# Actually changed to 10 minutes in code
CACHE_TTL = 600  
```

---

## WHAT TO DO INSTEAD

```python
# âœ… SYNC COMMENTS WITH CODE
def get_users():
    """Returns dict with 'users' list and 'count' int."""
    return {"users": [...], "count": 10}

# Update comments when changing code:
CACHE_TTL = 600  # Cached for 10 minutes
```

---

## PREVENTION

1. **Review Comments** when changing code
2. **Delete Stale Comments** rather than keep wrong ones
3. **Prefer Self-Documenting Code** over comments
4. **Use Docstrings** for API documentation

---

## DETECTION

```bash
# Look for common stale comment patterns
grep -r "TODO.*201[0-9]" src/  # Old TODOs
grep -r "FIXME.*201[0-9]" src/  # Old FIXMEs
grep -r "HACK" src/  # Temporary hacks that became permanent
```

---

## RELATED

- **AP-25** - Undocumented Decisions

---

**Keywords:** comments, documentation, stale comments, code evolution

---

**END OF AP-26**

---

# File: Documentation-Index.md

**Category:** Anti-Patterns  
**Topic:** Documentation  
**Items:** 2  
**Version:** 1.0.0

---

## FILES

### AP-25: Undocumented Decisions
- **Severity:** ðŸŸ  High
- **Problem:** Design choices without rationale
- **Solution:** Create DEC-## entries in neural maps

### AP-26: Stale Comments
- **Severity:** ðŸŸ¡ Medium
- **Problem:** Comments contradicting code
- **Solution:** Update comments with code, delete if stale

---

**Common Theme:** Documentation should help, not mislead.

---

**Keywords:** documentation, comments, decisions

**END OF INDEX**

---

# File: AP-27.md

**REF-ID:** AP-27  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Type:** Process  
**Severity:** ðŸŸ  High  
**Status:** Active

---

## SUMMARY

Skipping the 5-step verification protocol (LESS-15) before implementing changes. Leads to anti-pattern violations and bugs.

---

## THE ANTI-PATTERN

```
User: "Can I use threading locks?"
AI: "Sure, here's the code:"
[Outputs code with threading.Lock()]

# Skipped verification â†' Violated AP-08!
```

---

## WHAT TO DO INSTEAD

```
User: "Can I use threading locks?"
AI: [LESS-15 Step 3: Check anti-patterns]
    â†' Check AP-08: Threading locks
    â†' Severity: Critical
    â†' Lambda is single-threaded
AI: "NO - Lambda is single-threaded (AP-08).
     Locks add overhead without benefit.
     See DEC-04 for decision rationale."
```

---

## THE 5-STEP PROTOCOL (LESS-15)

1. **Read Complete File** - Never partial
2. **Verify SUGA Pattern** - Gateway â†' Interface â†' Core
3. **Check Anti-Patterns** - Review AP-## checklist
4. **Verify Dependencies** - Check import rules
5. **Cite Sources** - Provide REF-IDs

**Time Required:** 2-3 minutes  
**Bugs Prevented:** ~90% of common mistakes

---

## WHY IT MATTERS

**Verification Catches:**
- Anti-pattern violations (AP-##)
- Import rule violations (RULE-01)
- Architecture violations (SUGA)
- Circular dependencies
- Security issues

**Without Verification:**
- Anti-patterns slip through
- Bugs reach production
- Time wasted debugging
- Technical debt accumulates

---

## RELATED

- **LESS-15** - 5-Step Verification Protocol
- **AP-28** - Not Reading Complete Files

---

**Keywords:** verification, code review, quality assurance, LESS-15

---

**END OF AP-27**

---

# File: AP-28.md

**REF-ID:** AP-28  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Type:** Process  
**Severity:** ðŸ"´ Critical  
**Status:** Active

---

## SUMMARY

Reading only part of a file before making changes. Leads to incomplete understanding and broken code.

---

## THE ANTI-PATTERN

```
AI: "I'll update cache_core.py"
[Reads first 50 lines only]
[Makes changes based on partial understanding]
[Breaks code that was in lines 100-200]
```

---

## WHAT TO DO INSTEAD

```
AI: "I'll update cache_core.py"
[Fetches COMPLETE file]
[Reads ALL lines: 1-280]
[Understands full context]
[Makes informed changes]
[Includes ALL existing code in output]
```

---

## WHY IT'S CRITICAL

**Partial Reading Causes:**
1. **Missed Dependencies** - Don't see related functions
2. **Duplicate Code** - Add functionality that exists
3. **Break Existing Code** - Change shared variables
4. **Lost Context** - Miss important comments/decisions

**LESS-01 Rule:**
"ALWAYS read the COMPLETE file before making changes."

---

## VERIFICATION

**Before Changing File:**
- [ ] Fetched complete file
- [ ] Read all lines
- [ ] Understand full context
- [ ] Identified all dependencies
- [ ] Ready to make informed change

---

## ARTIFACT RULE

**When Outputting Modified File:**
```
âœ… Include ALL existing code + modifications
âœ… Mark changes with comments (# ADDED:, # MODIFIED:)
âœ… Full, deployable file
âœ… User can copy/paste immediately

âŒ NEVER partial snippets
âŒ NEVER "add this to line X"
âŒ NEVER fragments or excerpts
```

---

## RELATED

- **LESS-01** - Read Complete Files
- **LESS-15** - Verification Protocol
- **AP-27** - Skip Verification

---

**Keywords:** complete files, context, code review, artifacts

---

**END OF AP-28**

---

# File: Process-Index.md

**Category:** Anti-Patterns  
**Topic:** Process  
**Items:** 2  
**Version:** 1.0.0

---

## FILES

### AP-27: Skip Verification Protocol
- **Severity:** ðŸŸ  High
- **Problem:** Not using LESS-15 before changes
- **Solution:** Always complete 5-step verification

### AP-28: Not Reading Complete Files
- **Severity:** ðŸ"´ Critical
- **Problem:** Partial file reading before modifications
- **Solution:** Fetch and read complete file (LESS-01)

---

**Common Theme:** Process discipline prevents mistakes.

---

**Keywords:** verification, code review, process

**END OF INDEX**
