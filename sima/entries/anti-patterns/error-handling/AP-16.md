# AP-16.md - Losing Error Context

**REF-ID:** AP-16  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Topic:** Error Handling  
**Priority:** üü° MEDIUM  
**Status:** Active  
**Created:** 2025-10-30  
**Last Updated:** 2025-10-30

---

## Summary

Raising new exceptions without preserving original error context. This loses stack traces and makes debugging harder by breaking the chain of causation.

---

## Context

When handling one exception and raising another, developers often forget to chain them. This severs the connection between cause and effect, hiding valuable debugging information.

**Problem:** Lost stack traces, missing root cause, harder debugging.

---

## Content

### The Anti-Pattern

```python
# ‚ùå LOSING CONTEXT - Original exception discarded
try:
    process_data(data)
except ValueError:
    raise RuntimeError("Processing failed")
    # Lost: What ValueError? Where? Why?
```

### Why This Is Wrong

**Lost information:**
```python
# Original error:
# ValueError: invalid literal for int() with base 10: 'abc'
#   File "app.py", line 42, in process_data
#   File "parser.py", line 15, in parse_value

# Error user sees:
# RuntimeError: Processing failed
#   File "app.py", line 45, in process_data

# Lost:
# - Original ValueError message
# - Stack trace showing where conversion failed
# - Context about what value caused the error
```

**Debugging nightmare:**
```python
# Production error: "Processing failed"
# Questions:
# - What was being processed?
# - What actually failed?
# - ValueError? KeyError? Something else?
# - Where in the code did it start?

# All answers lost when context discarded
```

### Python Exception Chaining

**Python 3 provides explicit chaining:**
```python
# ‚úÖ EXPLICIT CHAINING - from e
try:
    operation()
except OriginalError as e:
    raise NewError("Context message") from e
```

**Result:**
```
Traceback (most recent call last):
  File "app.py", line 10, in operation
    risky_call()
OriginalError: original message
    [full stack trace of original error]

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "app.py", line 12, in wrapper
    raise NewError("Context message") from e
NewError: Context message
    [stack trace of new error]
```

### Correct Approaches

**Approach 1: Add context and chain:**
```python
# ‚úÖ ADD CONTEXT WITH CHAINING
try:
    process_data(data)
except ValueError as e:
    raise ValueError(f"Processing failed for {data}: {e}") from e
    # Preserves: original error, stack trace, adds context
```

**Approach 2: Transform with chaining:**
```python
# ‚úÖ TRANSFORM ERROR TYPE WITH CONTEXT
try:
    parse_config(file_path)
except json.JSONDecodeError as e:
    raise ConfigError(f"Invalid JSON in {file_path}") from e
    # Better error type for callers, preserves original
```

**Approach 3: Just re-raise (simplest):**
```python
# ‚úÖ RE-RAISE WITHOUT MODIFICATION
try:
    operation()
except SpecificError:
    logging.error("Operation failed, retrying...")
    raise  # No modification - complete context preserved
```

**Approach 4: Suppress chaining (rare):**
```python
# ‚ö†Ô∏è SUPPRESS CHAINING - from None (rare valid use)
try:
    load_from_cache()
except CacheMissError as e:
    # Cache miss is expected, not an error
    # Don't want stack trace in business logic exception
    raise NotFoundError("Item not found") from None
```

### Detection

```bash
# Find raises without chaining (potential issues)
grep -rn "raise.*Error" src/ | grep -v "from e" | grep -v "from None"

# Better: use static analysis
# pylint will flag some cases
pylint --disable=all --enable=raise-missing-from src/
```

### Examples by Scenario

**Database errors:**
```python
# ‚úÖ PRESERVE DB ERROR DETAILS
try:
    db.execute(query)
except db.IntegrityError as e:
    raise ValidationError(
        f"Duplicate entry for key '{key}'"
    ) from e
    # Preserves: constraint name, table, original SQL error
```

**API errors:**
```python
# ‚úÖ PRESERVE API ERROR DETAILS  
try:
    response = requests.get(url)
    response.raise_for_status()
except requests.HTTPError as e:
    raise APIError(
        f"Failed to fetch from {url}: {e.response.status_code}"
    ) from e
    # Preserves: original HTTP error, response details
```

**File errors:**
```python
# ‚úÖ PRESERVE FILE ERROR DETAILS
try:
    with open(path) as f:
        return f.read()
except IOError as e:
    raise DataLoadError(
        f"Cannot read file {path}"
    ) from e
    # Preserves: permission error, path details, errno
```

### When NOT to Chain

**Expected business logic "errors":**
```python
# ‚úÖ BUSINESS LOGIC - from None acceptable
try:
    user = get_from_cache(user_id)
except CacheMissError:
    # Cache miss is normal business logic, not an error condition
    raise UserNotFound(user_id) from None
```

**Security - hiding implementation:**
```python
# ‚úÖ SECURITY - from None to hide internals
try:
    authenticate(password)
except DatabaseError as e:
    logging.error(f"Auth DB error: {e}")
    # Don't reveal DB structure to attacker
    raise AuthenticationError("Invalid credentials") from None
```

### Testing Error Context

```python
# ‚úÖ TEST EXCEPTION CHAINING
def test_error_context_preserved():
    with pytest.raises(ConfigError) as exc_info:
        load_invalid_config()
    
    # Verify chaining
    assert exc_info.value.__cause__ is not None
    assert isinstance(exc_info.value.__cause__, JSONDecodeError)

def test_error_message_includes_context():
    with pytest.raises(ValidationError) as exc_info:
        process_invalid_data()
    
    # Verify context in message
    assert "invalid data" in str(exc_info.value).lower()
```

---

## Related Topics

- **AP-14**: Bare Except - Related error hiding
- **AP-15**: Swallowing Exceptions - Complete information loss

---

## Keywords

exception chaining, error context, stack trace, from e, debugging, root cause

---

## Version History

- **2025-10-30**: Created - Added Python 3 chaining patterns and security considerations

---

**File:** `AP-16.md`  
**Lines:** ~185  
**End of Document**
