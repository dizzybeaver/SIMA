# File: AP-08.md

**REF-ID:** AP-08  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Type:** Concurrency  
**Severity:** ðŸ"´ Critical  
**Status:** Active

---

## SUMMARY

Using threading locks, queues, or other synchronization primitives in AWS Lambda. Lambda is single-threaded; these add overhead without benefit and indicate architectural misunderstanding.

---

## THE ANTI-PATTERN

```python
# âŒ THREADING IN LAMBDA
import threading

lock = threading.Lock()
queue = threading.Queue()

def process_data(data):
    with lock:  # Unnecessary in Lambda!
        result = expensive_operation(data)
    return result
```

---

## WHY IT'S WRONG

**Lambda is Single-Threaded:**
- Each invocation runs in one thread
- No concurrent access within invocation
- Locks provide zero benefit
- Only add overhead

**DEC-04 Decision:**
"No threading primitives. Lambda environment is single-threaded by design."

---

## WHAT TO DO INSTEAD

```python
# âœ… NO LOCKS NEEDED
def process_data(data):
    # Direct processing - no synchronization needed
    result = expensive_operation(data)
    return result
```

---

## PERFORMANCE IMPACT

```
With unnecessary lock:
- Lock acquisition: ~100ns
- Lock release: ~100ns
- Total overhead: ~200ns per operation

For 1000 operations:
- Wasted time: 200Âµs
- Plus mental overhead
- Plus code complexity
```

---

## DETECTION

```bash
# Find threading imports
grep -r "import threading" src/
grep -r "from threading import" src/

# Should return ZERO results
```

---

## COMMON MISTAKES

1. **Coming from multithreaded background**
2. **Copying code from non-Lambda contexts**
3. **Misunderstanding Lambda execution model**
4. **Premature optimization**

---

## RELATED

- **DEC-04** - No Threading Locks
- **AP-11** - Race Conditions
- **AP-13** - Multiprocessing

---

**Keywords:** threading, locks, Lambda, single-threaded, concurrency

---

**END OF AP-08**

---

# File: AP-11.md

**REF-ID:** AP-11  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Type:** Concurrency  
**Severity:** ðŸŸ  High  
**Status:** Active

---

## SUMMARY

Worrying about race conditions or concurrent access in Lambda code. Lambda invocations are isolated; no shared state between invocations.

---

## THE ANTI-PATTERN

```python
# âŒ RACE CONDITION CONCERNS IN LAMBDA
shared_counter = 0  # This doesn't work as expected anyway!

def increment_counter():
    global shared_counter
    # Worried about race condition here?
    # Don't be - each invocation is isolated!
    shared_counter += 1
    return shared_counter
```

---

## WHY IT'S WRONG

**Lambda Isolation:**
- Each invocation = separate container
- No shared memory between invocations
- Global variables reset per cold start
- Warm invocations reuse container

**What Actually Happens:**
```
Invocation 1: shared_counter = 1
Invocation 2: shared_counter = 1 (different container!)
Invocation 3: shared_counter = 2 (reused Invocation 1 container)
```

---

## PROPER STATE MANAGEMENT

```python
# âœ… USE EXTERNAL STATE
def increment_counter():
    current = gateway.cache_get("counter") or 0
    new_value = current + 1
    gateway.cache_set("counter", new_value)
    return new_value
```

---

## WHEN CONCURRENCY MATTERS

**Between Invocations (External State):**
- Cache operations
- Database updates  
- External API calls

**Use:**
- Optimistic locking
- Conditional updates
- Atomic operations

---

## RELATED

- **AP-08** - Threading Locks
- **BUG-03** - Memory Leak from Global State

---

**Keywords:** race conditions, Lambda isolation, concurrency, shared state

---

**END OF AP-11**

---

# File: AP-13.md

**REF-ID:** AP-13  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Type:** Concurrency  
**Severity:** ðŸŸ  High  
**Status:** Active

---

## SUMMARY

Using multiprocessing in Lambda. Lambda's execution environment doesn't support true multiprocessing; attempts add complexity without benefit.

---

## THE ANTI-PATTERN

```python
# âŒ MULTIPROCESSING IN LAMBDA
from multiprocessing import Pool

def process_batch(items):
    with Pool(4) as pool:  # Won't work as expected!
        results = pool.map(process_item, items)
    return results
```

---

## WHY IT'S WRONG

**Lambda Constraints:**
- Limited CPU allocation
- Single-process design
- Process creation overhead high
- No real parallelism benefit

---

## WHAT TO DO INSTEAD

**For Parallel Processing:**
```python
# âœ… Use Step Functions or multiple Lambda invocations
# Each item gets its own Lambda
def process_item(item):
    return expensive_operation(item)

# Invoke multiple Lambdas in parallel via Step Functions
```

**For Batch Processing:**
```python
# âœ… Sequential processing is fine
def process_batch(items):
    results = []
    for item in items:
        results.append(process_item(item))
    return results
```

---

## ALTERNATIVES

1. **Step Functions** - Parallel Lambda invocations
2. **SQS + Multiple Lambdas** - Distributed processing
3. **Sequential** - Often fast enough

---

## RELATED

- **AP-08** - Threading Locks
- **AP-11** - Race Conditions

---

**Keywords:** multiprocessing, parallelism, Lambda, Step Functions

---

**END OF AP-13**

---

# File: Concurrency-Index.md

**Category:** Anti-Patterns  
**Topic:** Concurrency  
**Items:** 3  
**Version:** 1.0.0

---

## FILES

### AP-08: Threading Locks
- **Severity:** ðŸ"´ Critical
- **Problem:** Using threading primitives in single-threaded Lambda
- **Key:** Lambda is single-threaded by design

### AP-11: Race Conditions
- **Severity:** ðŸŸ  High
- **Problem:** Worrying about concurrent access within Lambda
- **Key:** Invocations are isolated

### AP-13: Multiprocessing
- **Severity:** ðŸŸ  High
- **Problem:** Using multiprocessing in Lambda
- **Key:** Use Step Functions for parallelism

---

## COMMON THEME

**Lambda Execution Model:**
- Single-threaded invocations
- Isolated containers
- No shared memory
- External state only

---

**Keywords:** concurrency, threading, Lambda, single-threaded, isolation

**END OF INDEX**
