# File: AP-03.md

**REF-ID:** AP-03  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Type:** Import Violations  
**Severity:** âšª Low  
**Status:** Active

---

## SUMMARY

Using gateway for operations within the same interface when direct calls would work. While not architecturally wrong, it adds unnecessary overhead for intra-interface operations.

---

## THE ANTI-PATTERN

### What's Suboptimal

```python
# âš ï¸ SUBOPTIMAL - Using gateway for same-interface operations
# In cache_operations.py (part of CACHE interface)
import gateway

def complex_cache_operation(key):
    # All same interface, but going through gateway
    value = gateway.cache_get(key)
    gateway.cache_validate(value)
    gateway.cache_transform(value)
    return gateway.cache_set(key, value)
```

### Why It's Suboptimal

1. **Unnecessary Overhead** - Gateway routing adds ~100ns per call
2. **Indirection** - Extra layer when direct call works
3. **Readability** - Less clear that it's same-interface
4. **Performance** - Adds up in hot paths (1000+ calls)

**Note:** This is NOT a critical violation - code works correctly, just not optimally.

---

## WHAT TO DO INSTEAD

### Better Approach

```python
# âœ… BETTER - Direct intra-interface calls
# In cache_operations.py (part of CACHE interface)
from cache_core import get_value, validate_entry, transform_value, set_value

def complex_cache_operation(key):
    # Same interface, direct calls
    value = get_value(key)
    validate_entry(value)
    transform_value(value)
    return set_value(key, value)
```

### Why This Is Better

- No gateway overhead
- Clear intra-interface relationship
- Better performance in hot paths
- Standard practice within interfaces

---

## WHEN IT MATTERS

### Performance Impact

```
Single call:
    Gateway route: ~100ns
    Direct call: ~10ns
    Overhead: 90ns

Hot path (1000 calls):
    Gateway overhead: 90Âµs (0.09ms)
    Direct calls: 10Âµs (0.01ms)
    Difference: 80Âµs (noticeable)

Cold path (< 10 calls):
    Overhead: < 1Âµs (negligible)
```

### When to Optimize

**Optimize (use direct):**
- Hot paths (called 100+ times per request)
- Performance-critical sections
- Inner loops
- High-frequency operations

**Don't optimize (gateway OK):**
- Code called once per request
- Initialization code
- Error handling paths
- Configuration loading

---

## REAL-WORLD EXAMPLE

### Context

Cache interface doing internal operations.

### Initial Code

```python
# In cache_operations.py
import gateway

def batch_cache_operation(keys):
    results = []
    for key in keys:  # Loop called 1000 times
        value = gateway.cache_get(key)
        processed = gateway.cache_process(value)
        gateway.cache_set(key, processed)
        results.append(processed)
    return results
```

### Performance Measurement

```
1000 iterations:
    Gateway overhead: 100ms
    Direct calls: 10ms
    Difference: 90ms (9000% slower!)
```

### Optimized Code

```python
# In cache_operations.py
from cache_core import get_value, process_value, set_value

def batch_cache_operation(keys):
    results = []
    for key in keys:
        value = get_value(key)
        processed = process_value(value)
        set_value(key, processed)
        results.append(processed)
    return results
```

### Result

- 90ms improvement in hot path
- Still architecturally sound
- More readable code

---

## THE BALANCING ACT

### Use Gateway When

- **Uncertain if same interface** - Gateway always safe
- **Code might move** - May change interfaces later
- **Readability preferred** - Consistent pattern
- **Consistency valued** - Same pattern everywhere

### Use Direct Calls When

- **Certain it's same interface** - No architectural risk
- **Performance matters** - Hot path optimization
- **Code structure stable** - Won't move interfaces
- **Following patterns** - Established in that interface

---

## HOW TO IDENTIFY

### Code Smells

- `import gateway` in files that are part of an interface
- Gateway calls to functions in same module/interface
- Performance profiling shows gateway overhead in hot paths

### When It Matters

**Hot paths:**
- Functions called 100+ times per request
- Inner loops
- Real-time processing

**Cold paths (doesn't matter):**
- Initialization code
- One-time operations
- Error handling

---

## EXCEPTION: GATEWAY IS FINE

### When Gateway Is Acceptable

```python
# âœ… ACCEPTABLE - Infrequent operation
# In cache_init.py
import gateway

def initialize_cache():
    # Called once at startup, gateway overhead irrelevant
    gateway.cache_clear()
    gateway.cache_warmup()
```

### Reasons It's OK

1. **Called infrequently** - Once per Lambda cold start
2. **Not performance critical** - Initialization path
3. **Consistent pattern** - Easier to understand
4. **May move interfaces** - Future refactoring flexibility

---

## RELATED PATTERNS

### Must Read First
- **GATE-05** - Intra vs Cross-Interface Imports
- **GATE-03** - Cross-Interface Communication

### Related Rules
- **RULE-01** - Gateway-only for cross-interface (this is exception)

### Related Anti-Patterns
- **AP-01** - Direct Cross-Interface (the critical one)
- **AP-12** - Premature Optimization

### Related Lessons
- **LESS-02** - Measure Don't Guess (profile first)

---

## DETECTION AND PREVENTION

### Code Review Questions

- Is this same interface? â†' Consider direct call
- Is this a hot path? â†' Profile and measure
- Does overhead matter? â†' Benchmark it
- Will code move? â†' Gateway provides flexibility

### Profiling

```python
# Measure before optimizing
import time

def profile_calls():
    # Gateway approach
    start = time.perf_counter()
    for _ in range(1000):
        gateway.cache_get("key")
    gateway_time = time.perf_counter() - start
    
    # Direct approach
    start = time.perf_counter()
    for _ in range(1000):
        cache_core.get_value("key")
    direct_time = time.perf_counter() - start
    
    print(f"Gateway: {gateway_time}ms")
    print(f"Direct: {direct_time}ms")
    print(f"Overhead: {gateway_time - direct_time}ms")
```

---

## MIGRATION GUIDE

### Should You Optimize?

**Step 1:** Profile your code
```bash
python -m cProfile -o profile.stats your_script.py
python -m pstats profile.stats
```

**Step 2:** Identify hot paths
```python
# Look for functions called 100+ times
# Check if gateway calls dominate timing
```

**Step 3:** Verify same interface
```python
# Confirm all operations are within same interface
# Check module names and purpose
```

**Step 4:** Optimize if worthwhile
```python
# Replace gateway calls with direct imports
# Measure improvement
```

**Step 5:** Document decision
```python
# Add comment explaining why direct calls used
# "Direct calls used - hot path with 1000 iterations"
```

---

## SEVERITY JUSTIFICATION

### Why Low Priority

1. **Works Correctly** - No architectural violation
2. **Small Overhead** - 100ns per call (usually negligible)
3. **Rare Impact** - Only matters in hot paths
4. **Easy Fix** - Simple import change
5. **Not Breaking** - Doesn't cause failures

### When to Address

- **High:** Hot path with measurable impact (>10ms)
- **Medium:** Moderate frequency (100-1000 calls)
- **Low:** Infrequent operations (<100 calls)
- **Ignore:** Cold paths and initialization

---

## KEYWORDS

same-interface, intra-interface, performance, micro-optimization, gateway overhead, hot paths

---

## VERSION HISTORY

### [1.0.0] - 2025-10-30
- Migrated to SIMAv4 format
- Added performance measurements
- Added profiling guidance
- Enhanced optimization decision tree

### [0.9.0] - 2025-10-23
- SIMA v3 individual file format

### [0.1.0] - 2024-10-15
- Initial documentation

---

**END OF ANTI-PATTERN ENTRY**

**Related:** AP-01, AP-02, AP-12, GATE-03, GATE-05, LESS-02
