# DT-01.md

**REF-ID:** DT-01  
**Category:** Decision Logic  
**Subcategory:** Import  
**Name:** How to Import Functionality  
**Priority:** Critical  
**Status:** Active  
**Created:** 2024-10-30  
**Updated:** 2024-10-30

---

## Summary

Decision tree for determining correct import patterns - when to use gateway imports vs direct imports based on interface boundaries and architecture rules.

---

## Problem

When functionality is needed from another part of the codebase, developers must choose between gateway imports (cross-interface) and direct imports (same-interface). Wrong choices violate architecture patterns and create maintenance issues.

---

## Context

Gateway architecture uses three layers:
- **Gateway Layer:** Central routing and interface access
- **Interface Layer:** Domain-specific routers and wrappers
- **Core Layer:** Implementation logic

Imports must respect layer boundaries to prevent circular dependencies and maintain clean architecture.

---

## Decision Tree

```
START: Need to import function X
│
├─ Q: Is X in the same interface?
│  ├─ YES → Direct import
│  │      Example: cache_core.py imports from cache_operations.py
│  │      Pattern: from cache_operations import function
│  │      → END
│  │
│  └─ NO → Continue
│
├─ Q: Is X in a different interface?
│  ├─ YES → Gateway import
│  │      Example: cache_core.py needs logging
│  │      Pattern: from gateway import log_info
│  │      → END
│  │
│  └─ NO → Continue
│
├─ Q: Is X a standard library or external module?
│  ├─ YES → Direct import
│  │      Example: import json, import requests
│  │      Pattern: import module
│  │      → END
│  │
│  └─ NO → Continue
│
└─ Q: Is X from lambda_function.py (entry point)?
   └─ YES → Use gateway
          Entry point should never be imported
          Pattern: from gateway import function
          → END
```

---

## Decision Matrix

| Source Location | Target Location | Import Pattern | Example |
|----------------|-----------------|----------------|---------|
| cache_core.py | cache_operations.py | Direct | `from cache_operations import get_key` |
| cache_core.py | logging_core.py | Gateway | `from gateway import log_info` |
| Any file | Standard library | Direct | `import json` |
| Any file | External package | Direct | `import requests` |
| Any file | lambda_function.py | Gateway | `from gateway import handler` |

---

## Examples

### Example 1: Same Interface - Direct Import

**Scenario:**
Working in `cache_core.py`, need function from `cache_operations.py`

**Decision:**
- Same interface? YES (both CACHE interface)
- **Pattern:** Direct import

**Implementation:**
```python
# In cache_core.py
from cache_operations import validate_key, sanitize_value

def cache_set(key, value, ttl=300):
    """Set cache value with validation."""
    if not validate_key(key):  # Direct import within interface
        raise ValueError(f"Invalid key: {key}")
    cleaned = sanitize_value(value)
    return _set_to_cache(key, cleaned, ttl)
```

### Example 2: Cross-Interface - Gateway Import

**Scenario:**
Working in `cache_core.py`, need logging functionality

**Decision:**
- Same interface? NO (CACHE vs LOGGING)
- Different interface? YES
- **Pattern:** Gateway import

**Implementation:**
```python
# In cache_core.py
from gateway import log_info, log_error  # Gateway import for cross-interface

def cache_set(key, value, ttl=300):
    """Set cache value with logging."""
    log_info(f"Setting cache key: {key}")  # Via gateway
    try:
        result = _set_to_cache(key, value, ttl)
        log_info(f"Cache set successful: {key}")
        return result
    except Exception as e:
        log_error(f"Cache set failed: {key}", error=e)
        raise
```

### Example 3: Standard Library - Direct Import

**Scenario:**
Need JSON parsing in any file

**Decision:**
- Standard library? YES
- **Pattern:** Direct import

**Implementation:**
```python
# Any file
import json
import time
from datetime import datetime

def process_data(data_str):
    """Process JSON data."""
    data = json.loads(data_str)  # Direct stdlib import
    timestamp = datetime.now()
    return {'data': data, 'timestamp': timestamp.isoformat()}
```

### Example 4: Entry Point - Never Import Directly

**Scenario:**
Need handler function from `lambda_function.py`

**Decision:**
- From lambda_function? YES
- **Pattern:** Use gateway wrapper

**Implementation:**
```python
# ❌ NEVER DO THIS
from lambda_function import handler  # WRONG - breaks architecture

# ✅ CORRECT
from gateway import process_request  # Via gateway wrapper
```

---

## Anti-Patterns

### ❌ AP-01: Direct Cross-Interface Import

**Problem:**
```python
# In cache_core.py
from logging_core import log_info  # WRONG - bypasses gateway
```

**Why Wrong:**
- Violates gateway pattern
- Creates tight coupling
- Enables circular dependencies
- Breaks interface isolation

**Solution:**
```python
# In cache_core.py
from gateway import log_info  # CORRECT - via gateway
```

### ❌ AP-04: Circular Import via Gateway

**Problem:**
```python
# In interface_a.py
from gateway import function_b

# In interface_b.py  
from gateway import function_a  # Creates circular dependency
```

**Why Wrong:**
- Gateway can't initialize both
- Python import system fails
- Runtime errors

**Solution:**
- Refactor to remove circular dependency
- One interface should not depend on another bidirectionally
- Consider creating shared utility interface

### ❌ AP-05: Importing from Entry Point

**Problem:**
```python
# Any file
from lambda_function import handler  # WRONG
```

**Why Wrong:**
- Entry point should never be imported
- Causes initialization issues
- Breaks testing isolation

**Solution:**
```python
# Use gateway wrapper
from gateway import process_request  # CORRECT
```

---

## Usage Patterns

### Pattern 1: Module Initialization

**When:**
Setting up module-level constants or singletons

**Import Pattern:**
```python
# At top of file
from gateway import get_config, log_info  # Cross-interface via gateway
from module_helpers import validate_input  # Same-interface direct

# Module initialization
CONFIG = get_config('module_settings')
log_info(f"Module initialized with config: {CONFIG}")
```

### Pattern 2: Conditional Imports

**When:**
Optional dependencies or feature flags

**Import Pattern:**
```python
# Standard conditional import
try:
    import optional_package
    HAS_OPTIONAL = True
except ImportError:
    HAS_OPTIONAL = False

# Gateway imports are always available
from gateway import log_warning  # No try/except needed

if not HAS_OPTIONAL:
    log_warning("Optional package not available, using fallback")
```

### Pattern 3: Type Hints

**When:**
Type annotations without runtime dependency

**Import Pattern:**
```python
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    # Import only for type checking, not runtime
    from other_interface import ComplexType

def process_data(data: 'ComplexType') -> dict:
    """Process data with type hints."""
    # No runtime dependency on other_interface
    pass
```

---

## Decision Flowchart

```
┌─────────────────────────────┐
│ Need to import function X   │
└──────────┬──────────────────┘
           │
           ▼
    ┌──────────────┐
    │ Same         │  YES ─► Direct Import
    │ Interface?   │           (from module import func)
    └──────┬───────┘
           │ NO
           ▼
    ┌──────────────┐
    │ Different    │  YES ─► Gateway Import  
    │ Interface?   │           (from gateway import func)
    └──────┬───────┘
           │ NO
           ▼
    ┌──────────────┐
    │ Standard     │  YES ─► Direct Import
    │ Library?     │           (import module)
    └──────┬───────┘
           │ NO
           ▼
    ┌──────────────┐
    │ Entry Point? │  YES ─► Use Gateway Wrapper
    └──────────────┘           (from gateway import wrapper)
```

---

## Related Patterns

**From NM02 (Dependencies):**
- **RULE-01:** Gateway-only cross-interface imports
- **RULE-02:** No circular dependencies
- **DEP-01 to DEP-05:** Dependency layer hierarchy

**From NM04 (Decisions):**
- **DEC-01:** Gateway architecture choice
- **DEC-02:** Centralized import management

**From NM05 (Anti-Patterns):**
- **AP-01:** Direct cross-interface imports
- **AP-02:** Importing interface routers
- **AP-04:** Circular imports
- **AP-05:** Importing entry point

**From NM07 (Decision Logic):**
- **DT-02:** Where should function go?
- **DT-13:** Should I create new interface?

---

## Keywords

import, gateway, cross-interface, same-interface, direct import, gateway import, circular dependency, import pattern, architecture

---

## Version History

- **2024-10-30:** Migrated to SIMAv4 format from NM07 v3
- **2024-10-24:** Created in SIMAv3 format

---

**File:** `DT-01.md`  
**Location:** `/sima/entries/decision-logic/import/`  
**End of Document**
