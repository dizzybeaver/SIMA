# File: AP-06.md

**REF-ID:** AP-06  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Type:** Implementation  
**Severity:** ðŸŸ  High  
**Status:** Active

---

## SUMMARY

Creating massive classes or modules with too many responsibilities instead of focused, single-purpose implementations. God objects violate single responsibility and become unmaintainable.

---

## THE ANTI-PATTERN

```python
# âŒ GOD OBJECT - Everything in one class
class SystemManager:
    def __init__(self):
        self.cache = {}
        self.logs = []
        self.metrics = {}
        self.http_sessions = []
        self.config = {}
        
    def cache_get(self, key): ...
    def cache_set(self, key, value): ...
    def log_info(self, msg): ...
    def log_error(self, msg): ...
    def record_metric(self, name, value): ...
    def make_http_request(self, url): ...
    def load_config(self): ...
    def validate_input(self, data): ...
    def format_response(self, data): ...
    # ... 50 more methods
```

---

## WHAT TO DO INSTEAD

```python
# âœ… FOCUSED MODULES - One responsibility each

# cache_core.py
def get_value(key): ...
def set_value(key, value): ...

# logging_core.py
def log_info(msg): ...
def log_error(msg): ...

# metrics_core.py
def record_metric(name, value): ...

# http_client_core.py
def make_request(url): ...
```

---

## WHY IT'S BAD

1. **Violates Single Responsibility** - One class does everything
2. **Hard to Test** - Must mock entire object
3. **Merge Conflicts** - Everyone editing same file
4. **Hard to Understand** - Too much in one place
5. **Tight Coupling** - Everything depends on everything

---

## REAL-WORLD EXAMPLE

**Problem:** Created `SystemCore` class with 2000+ lines handling cache, logging, HTTP, config.

**What Went Wrong:**
- 5 developers editing same file = constant merge conflicts
- Testing required mocking entire massive class
- Nobody understood the full scope
- Fear of breaking something

**Solution:** Split into interface-specific modules
- cache_core.py (280 lines)
- logging_core.py (220 lines)
- http_client_core.py (350 lines)
- Each testable independently

---

## RELATED

- **AP-07** - Large Modules
- **ARCH-01** - SUGA Pattern
- **DEC-17** - Flat File Structure

---

**Keywords:** god objects, single responsibility, focused modules

---

**END OF AP-06**

---

# File: AP-07.md

**REF-ID:** AP-07  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Type:** Implementation  
**Severity:** ðŸŸ¡ Medium  
**Status:** Active

---

## SUMMARY

Creating modules exceeding 400 lines (core) or 200 lines (interfaces). Large modules are hard to understand, maintain, and indicate missing abstractions.

---

## THE ANTI-PATTERN

```python
# âŒ LARGE MODULE - cache_operations.py (800+ lines)
"""Everything related to caching."""

# Cache implementation (200 lines)
class CacheStore: ...

# Cache operations (150 lines)
def get_value(key): ...
def set_value(key, value): ...
def delete_value(key): ...

# Cache validation (100 lines)
def validate_key(key): ...
def validate_value(value): ...

# Cache statistics (150 lines)
def get_cache_stats(): ...
def reset_cache_stats(): ...

# Cache management (200 lines)
def clear_cache(): ...
def warmup_cache(): ...
# ... more functions
```

---

## WHAT TO DO INSTEAD

```python
# âœ… FOCUSED MODULES - Split by responsibility

# cache_core.py (280 lines) - Core operations
def get_value(key): ...
def set_value(key, value): ...

# cache_validation.py (150 lines) - Validation
def validate_key(key): ...
def validate_value(value): ...

# cache_stats.py (120 lines) - Statistics
def get_stats(): ...
def reset_stats(): ...

# cache_management.py (180 lines) - Management
def clear_cache(): ...
def warmup_cache(): ...
```

---

## SIZE GUIDELINES

| Module Type | Max Lines | Typical |
|-------------|-----------|---------|
| Core | 400 | 200-300 |
| Interface | 200 | 100-150 |
| Gateway | 300 | 150-250 |
| Utility | 300 | 150-200 |

---

## WHY IT MATTERS

**Cognitive Load:**
- 300 lines: Fits in mental model
- 800 lines: Cannot hold in mind
- Result: Harder to understand and modify

**Maintenance:**
- Small files: Easy to refactor
- Large files: Fear of breaking things

**Team Work:**
- Small files: Parallel development
- Large files: Merge conflicts

---

## DETECTION

```bash
# Find large files
find src -name "*.py" -exec wc -l {} \; | sort -rn | head -10

# Flag files over limit
find src -name "*_core.py" -exec wc -l {} \; | awk '$1 > 400'
find src -name "interface_*.py" -exec wc -l {} \; | awk '$1 > 200'
```

---

## MIGRATION

**If module exceeds limit:**

1. **Identify logical sections**
2. **Extract to new files**
3. **Update imports**
4. **Test thoroughly**
5. **Document split decision**

---

## RELATED

- **AP-06** - God Objects
- **ARCH-09** - Module Size Limits
- **DEC-17** - Flat File Structure

---

**Keywords:** large modules, module size, code organization, maintainability

---

**END OF AP-07**

---

# File: Implementation-Index.md

**Category:** Anti-Patterns  
**Topic:** Implementation  
**Items:** 2  
**Version:** 1.0.0

---

## FILES

### AP-06: God Objects
- **Severity:** ðŸŸ  High
- **Problem:** Massive classes with too many responsibilities
- **Solution:** Split by interface, focused modules

### AP-07: Large Modules (>400 lines)
- **Severity:** ðŸŸ¡ Medium
- **Problem:** Monolithic files hard to understand
- **Solution:** Keep under size limits, split by responsibility

---

## COMMON THEME

Both patterns address **code organization and single responsibility**. They ensure modules remain:
- Focused
- Testable
- Maintainable
- Comprehensible

---

**Keywords:** implementation, module size, god objects, single responsibility

**END OF INDEX**
