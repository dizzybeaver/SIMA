# AP-15.md - Swallowing Exceptions

**REF-ID:** AP-15  
**Version:** 1.0.0  
**Category:** Anti-Patterns  
**Topic:** Error Handling  
**Priority:** üü† HIGH  
**Status:** Active  
**Created:** 2025-10-30  
**Last Updated:** 2025-10-30

---

## Summary

Catching exceptions and doing nothing with them (silent failures). This hides errors, makes debugging impossible, and can lead to data corruption.

---

## Context

During development, catching and ignoring exceptions seems convenient ("I'll fix it later"). In production, this leads to silent failures that are nearly impossible to diagnose.

**Problem:** Silent failures, impossible debugging, false success signals, potential data corruption.

---

## Content

### The Anti-Pattern

```python
# ‚ùå SWALLOWING EXCEPTIONS
try:
    critical_operation()
except Exception:
    pass  # Silent failure - error vanishes!

# Even worse - pretending success:
try:
    important_check()
except Exception:
    return True  # Lie about success!
```

### Why This Is Wrong

**1. Silent Failures**
```python
try:
    save_to_database(data)
except Exception:
    pass

# User thinks save succeeded
# Data actually lost
# No error logged
# No way to know what happened
```

**2. Impossible to Debug**
```python
# Production issue: "Feature X stopped working 3 days ago"
# Code review finds:
try:
    process_feature_x()
except Exception:
    pass  # When did this start failing? What's the error?

# No logs, no traces, no information
# Cannot diagnose or fix
```

**3. False Success**
```python
def validate_input(data):
    try:
        check_schema(data)
        check_bounds(data)
        check_business_rules(data)
        return True
    except Exception:
        return True  # !! LIES - validation failed but returns success
```

**4. Data Corruption**
```python
try:
    # Multi-step operation
    delete_old_record(id)  # Succeeds
    create_new_record(data)  # Fails
except Exception:
    pass  # Old deleted, new not created - data lost!
```

### Correct Approach

**Always log errors:**
```python
# ‚úÖ LOG AND HANDLE
import logging

try:
    critical_operation()
except ValueError as e:
    logging.error(f"Operation failed with invalid value: {e}")
    return default_value
except Exception as e:
    logging.error(f"Unexpected error: {e}", exc_info=True)
    raise  # Re-raise if cannot handle
```

**Provide meaningful defaults:**
```python
# ‚úÖ RETURN SENSIBLE DEFAULT
def get_config_value(key):
    try:
        return config.get(key)
    except KeyError:
        logging.warning(f"Config key '{key}' not found, using default")
        return DEFAULT_VALUES[key]
    except Exception as e:
        logging.error(f"Config error for key '{key}': {e}")
        raise  # Unexpected errors should propagate
```

**Re-raise when cannot handle:**
```python
# ‚úÖ RE-RAISE AFTER LOGGING
try:
    complex_operation()
except SpecificError as e:
    logging.error(f"Expected error occurred: {e}")
    # Can handle this specific error
    return fallback_value
except Exception as e:
    logging.error(f"Unexpected error: {e}", exc_info=True)
    raise  # Cannot handle - let caller deal with it
```

### When Suppression Is Acceptable

**Rare valid cases (must document WHY):**

```python
# ‚úÖ DOCUMENTED OPTIONAL OPERATION
try:
    record_optional_metric()
except Exception as e:
    # Explicitly documented: metrics are optional
    # Logged at debug level for troubleshooting
    logging.debug(f"Optional metric failed (ignored): {e}")
    pass  # Intentionally suppressed

# ‚úÖ CLEANUP IN FINALLY
try:
    process_data()
finally:
    try:
        cleanup_temp_files()
    except Exception as e:
        # Cleanup failure shouldn't hide main operation result
        logging.warning(f"Cleanup failed (non-critical): {e}")
        pass  # Intentionally suppressed
```

### Detection

```bash
# Find exception swallowing
grep -rn "except.*:\s*pass" src/
grep -rn "except.*:\s*$" src/  # Empty except block

# Find return in except without logging
grep -B2 "except" src/**/*.py | grep "return" | grep -v "log"

# Use static analysis
# pylint will flag some patterns
pylint --disable=all --enable=bare-except,lost-exception src/
```

### Testing for Swallowed Exceptions

```python
# ‚úÖ TESTS SHOULD VERIFY ERROR HANDLING
def test_operation_logs_errors(caplog):
    """Verify errors are logged, not swallowed."""
    with pytest.raises(ValueError):
        operation_that_should_fail()
    
    # Verify error was logged
    assert "expected error message" in caplog.text

def test_operation_handles_specific_error():
    """Verify specific errors are handled."""
    # Should NOT raise
    result = operation_that_catches_expected_error()
    
    # Should return meaningful value
    assert result is not None
    assert isinstance(result, ExpectedType)
```

### Real-World Example

**Before (swallowing):**
```python
def sync_data():
    try:
        fetch_from_api()
        transform_data()
        save_to_database()
    except Exception:
        pass  # "Error handling"

# Result:
# - Sync appears to complete successfully
# - Data actually not synced
# - No alerts, no logs
# - Discovered days later when reports are wrong
# - Impossible to determine when it started failing
```

**After (proper handling):**
```python
def sync_data():
    try:
        data = fetch_from_api()
        transformed = transform_data(data)
        save_to_database(transformed)
        logging.info("Sync completed successfully")
    except APIError as e:
        logging.error(f"API fetch failed: {e}", exc_info=True)
        raise SyncError("Failed to fetch data") from e
    except ValidationError as e:
        logging.error(f"Data transformation failed: {e}", exc_info=True)
        raise SyncError("Invalid data format") from e
    except DatabaseError as e:
        logging.error(f"Database save failed: {e}", exc_info=True)
        raise SyncError("Failed to save data") from e

# Result:
# - Failures immediately visible in logs
# - Alerts triggered on SyncError
# - Stack trace available for debugging
# - Can determine exactly which step failed
# - Can replay from logs to reproduce
```

---

## Related Topics

- **AP-14**: Bare Except - Related error hiding
- **AP-16**: No Error Context - Losing information
- **AP-24**: Testing Only Success Paths - Tests should verify error handling

---

## Keywords

swallowing exceptions, silent failures, error handling, logging, debugging, exception suppression

---

## Version History

- **2025-10-30**: Created - Added detection methods and testing guidelines

---

**File:** `AP-15.md`  
**Lines:** ~195  
**End of Document**
